[
["index.html", "Influence of land cover and climate on the occupancy of avian distributions along a tropical montane gradient Section 1 Introduction 1.1 Attribution 1.2 Data access 1.3 Data processing", " Influence of land cover and climate on the occupancy of avian distributions along a tropical montane gradient Vijay Ramesh, Pratik R Gupte, and Morgan Tingley 2020-01-09 Section 1 Introduction This is the bookdown version of a project in preparation that models occupancy for birds in the Nilgiri hills. Methods and format are derived from Strimas-Mackey et al., the supplement to Johnston et al. (2019). 1.1 Attribution Please contact the following in case of interest in the project. Vijay Ramesh (lead author) PhD student, Columbia University Pratik Gupte (repo maintainer) PhD student, University of Groningen Morgan Tingley (PI) 1.2 Data access The data used in this work are available from eBird. 1.3 Data processing The data processing for this project is described in the following sections. Navigate through them using the links in the sidebar. "],
["preparing-ebird-data.html", "Section 2 Preparing eBird data 2.1 Prepare libraries and data sources 2.2 Filter data 2.3 Process filtered data 2.4 Spatial filter 2.5 Handle presence data 2.6 Add decimal time 2.7 Write data", " Section 2 Preparing eBird data 2.1 Prepare libraries and data sources # load libs library(tidyverse) library(readr) library(sf) library(auk) library(readxl) # custom sum function sum.no.na &lt;- function(x){sum(x, na.rm = T)} # set file paths for auk functions f_in_ebd &lt;- file.path(&quot;ebd_Filtered_Jun2019.txt&quot;) f_in_sampling &lt;- file.path(&quot;ebd_sampling_Filtered_Jun2019.txt&quot;) 2.2 Filter data # add species of interest specieslist &lt;- read_excel(&quot;data/species_list_13_11_2019.xlsx&quot;) speciesOfInterest &lt;- specieslist$scientific_name # run filters using auk packages ebd_filters &lt;- auk_ebd(f_in_ebd, f_in_sampling) %&gt;% auk_species(speciesOfInterest) %&gt;% auk_country(country = &quot;IN&quot;) %&gt;% auk_state(c(&quot;IN-KL&quot;,&quot;IN-TN&quot;, &quot;IN-KA&quot;)) %&gt;% # Restricting geography to TamilNadu, Kerala &amp; Karnataka auk_date(c(&quot;2013-01-01&quot;, &quot;2018-12-31&quot;)) %&gt;% auk_complete() # check filters ebd_filters Below code need not be run if it has been filtered once already and the above path leads to the right dataset. NB: This is a computation heavy process, run with caution. # specify output location and perform filter f_out_ebd &lt;- &quot;data/eBirdDataWG_filtered.txt&quot; f_out_sampling &lt;- &quot;data/eBirdSamplingDataWG_filtered.txt&quot; ebd_filtered &lt;- auk_filter(ebd_filters, file = f_out_ebd, file_sampling = f_out_sampling, overwrite = TRUE) 2.3 Process filtered data # read in the data ebd &lt;- read_ebd(f_out_ebd) # fill zeroes zf &lt;- auk_zerofill(f_out_ebd, f_out_sampling) new_zf &lt;- collapse_zerofill(zf) # Creates a new zero-filled dataframe with a 0 marked for each checklist when the bird was not observed # choose columns of interest columnsOfInterest &lt;- c(&quot;checklist_id&quot;,&quot;scientific_name&quot;,&quot;observation_count&quot;,&quot;locality&quot;,&quot;locality_id&quot;,&quot;locality_type&quot;,&quot;latitude&quot;,&quot;longitude&quot;,&quot;observation_date&quot;,&quot;time_observations_started&quot;,&quot;observer_id&quot;,&quot;sampling_event_identifier&quot;,&quot;protocol_type&quot;,&quot;duration_minutes&quot;,&quot;effort_distance_km&quot;,&quot;effort_area_ha&quot;,&quot;number_observers&quot;,&quot;species_observed&quot;,&quot;reviewed&quot;) # make list of presence and absence data and choose cols of interest data &lt;- list(ebd, new_zf) %&gt;% map(function(x){ x %&gt;% select(one_of(columnsOfInterest)) }) # remove zerofills to save working memory rm(zf, new_zf); gc() # check presence and absence in absences df, remove essentially the presences df data[[2]] &lt;- data[[2]] %&gt;% filter(species_observed == F) 2.4 Spatial filter # load shapefiles of hill ranges library(sf) hills &lt;- st_read(&quot;data/spatial/hillsShapefile/Nil_Ana_Pal.shp&quot;) # write a prelim filter by bounding box box &lt;- st_bbox(hills) # get data spatial coordinates dataLocs &lt;- data %&gt;% map(function(x){ select(x, longitude, latitude) %&gt;% filter(between(longitude, box[&quot;xmin&quot;], box[&quot;xmax&quot;]) &amp; between(latitude, box[&quot;ymin&quot;], box[&quot;ymax&quot;]))}) %&gt;% bind_rows() %&gt;% distinct() %&gt;% st_as_sf(coords = c(&quot;longitude&quot;, &quot;latitude&quot;)) %&gt;% st_set_crs(4326) %&gt;% st_intersection(hills) # get simplified data and drop geometry dataLocs &lt;- mutate(dataLocs, spatialKeep = T) %&gt;% bind_cols(., as_tibble(st_coordinates(dataLocs))) %&gt;% st_drop_geometry() # bind to data and then filter data &lt;- data %&gt;% map(function(x){ left_join(x, dataLocs, by = c(&quot;longitude&quot; = &quot;X&quot;, &quot;latitude&quot; = &quot;Y&quot;)) %&gt;% filter(spatialKeep == T) %&gt;% select(-Id, -spatialKeep) }) # save a temp data file save(data, file = &quot;data.temp.rdata&quot;) 2.5 Handle presence data # in the first set, replace X, for presences, with 1 data[[1]] &lt;- data[[1]] %&gt;% mutate(observation_count = ifelse(observation_count == &quot;X&quot;, &quot;1&quot;, observation_count)) # remove records where duration is 0 data &lt;- map(data, function(x) filter(x, duration_minutes &gt; 0)) # group data by site and sampling event identifier # then, summarise relevant variables as the sum dataGrouped &lt;- map(data, function(x){ x %&gt;% group_by(sampling_event_identifier) %&gt;% summarise_at(vars(duration_minutes, effort_distance_km, effort_area_ha), list(sum.no.na)) }) # bind rows combining data frames, and filter dataGrouped &lt;- bind_rows(dataGrouped) %&gt;% filter(duration_minutes &lt;= 300, effort_distance_km &lt;= 5, effort_area_ha &lt;= 500) # get data identifiers, such as sampling identifier etc dataConstants &lt;- data %&gt;% bind_rows() %&gt;% select(sampling_event_identifier, time_observations_started, locality, locality_type, locality_id, observer_id, observation_date, scientific_name, observation_count, protocol_type, number_observers, longitude, latitude) # join the summarised data with the identifiers, using sampling_event_identifier as the key dataGrouped &lt;- left_join(dataGrouped, dataConstants, by = &quot;sampling_event_identifier&quot;) # remove checklists or seis with more than 10 obervers count(dataGrouped, number_observers &gt; 10) # count how many have 10+ obs dataGrouped &lt;- filter(dataGrouped, number_observers &lt;= 10) 2.6 Add decimal time # assign present or not, and get time in decimal hours since midnight library(lubridate) time_to_decimal &lt;- function(x) { x &lt;- hms(x, quiet = TRUE) hour(x) + minute(x) / 60 + second(x) / 3600 } # will cause issues if using time obs started as a linear effect and not quadratic dataGrouped = mutate(dataGrouped, pres_abs = observation_count &gt;= 1, decimalTime = time_to_decimal(time_observations_started)) # check class of dataGrouped, make sure not sf assertthat::assert_that(!&quot;sf&quot; %in% class(dataGrouped)) 2.7 Write data # save a temp data file save(dataGrouped, file = &quot;data_prelim_processing.rdata&quot;) "],
["prepare-landscape-data.html", "Section 3 Prepare landscape data 3.1 Prepare libraries 3.2 Prepare initial data 3.3 Resample rasters", " Section 3 Prepare landscape data 3.1 Prepare libraries # load libs library(raster) library(stringi) library(glue) library(gdalUtils) library(purrr) # prep mode function to aggregate funcMode &lt;- function(x, na.rm = T) { ux &lt;- unique(x) ux[which.max(tabulate(match(x, ux)))] } # a basic test assertthat::assert_that(funcMode(c(2,2,2,2,3,3,3,4)) == as.character(2), msg = &quot;problem in the mode function&quot;) # works 3.2 Prepare initial data 3.2.1 Prepare spatial extent # load hills library(sf) hills &lt;- st_read(&quot;data/spatial/hillsShapefile/Nil_Ana_Pal.shp&quot;) hills &lt;- st_transform(hills, 32643) buffer &lt;- st_buffer(hills, 3e4) %&gt;% st_transform(4326) 3.2.2 Prepare terrain rasters # load elevation and crop to hills size, then mask by hills alt &lt;- raster(&quot;data/spatial/Elevation/alt&quot;) alt.hills &lt;- crop(alt, as(buffer, &quot;Spatial&quot;)) rm(alt); gc() # get slope and aspect slopeData &lt;- terrain(x = alt.hills, opt = c(&quot;slope&quot;, &quot;aspect&quot;)) elevData &lt;- raster::stack(alt.hills, slopeData) rm(alt.hills); gc() 3.2.3 Prepare CHELSA rasters # list chelsa files chelsaFiles &lt;- list.files(&quot;data/chelsa/&quot;, full.names = TRUE, pattern = &quot;*.tif&quot;) # gather chelsa rasters chelsaData &lt;- purrr::map(chelsaFiles, function(chr){ a &lt;- raster(chr) crs(a) &lt;- crs(elevData) a &lt;- crop(a, as(buffer, &quot;Spatial&quot;)) return(a) }) # stack chelsa data chelsaData &lt;- raster::stack(chelsaData) 3.2.4 Stack prepared rasters # stack rasters for efficient reprojection later env_data &lt;- stack(elevData, chelsaData) 3.2.5 Prepare landcover # read in landcover raster location landcover &lt;- &quot;data/landUseClassification/Reprojected Image_8th Jan 2020_WGBuffer.tif&quot; # get extent e = bbox(raster(landcover)) # init resolution res_init &lt;- res(raster(landcover)) # res to transform to 1000m res_final &lt;- res_init*100 # use gdalutils gdalwarp for resampling transform # to 1km from 10m gdalwarp(srcfile = landcover, dstfile = &quot;data/landUseClassification/lc_01km.tif&quot;, tr=c(res_final), r=&#39;mode&#39;, te=c(e)) 3.3 Resample rasters 3.3.1 Read landcover as list Here, we read in the 1km landcover raster and set 0 to NA. lc_data &lt;- raster(&quot;data/landUseClassification/lc_01km.tif&quot;) lc_data[lc_data == 0] &lt;- NA 3.3.2 Reproject environmental data to landcover # resample to the corresponding landcover data env_data_resamp &lt;- projectRaster(from = env_data, to = lc_data, crs = crs(lc_data), res = res(lc_data)) # export as raster stack land_stack &lt;- stack(env_data_resamp, lc_data) # get names land_names &lt;- glue(&#39;data/spatial/landscape_resamp{c(&quot;01&quot;)}km.tif&#39;) # write to file writeRaster(land_stack, filename = as.character(land_names), overwrite=TRUE) "],
["prepare-observer-expertise.html", "Section 4 Prepare observer expertise 4.1 Prepare libraries 4.2 Prepare data 4.3 Explicit spatial subset 4.4 Prepare species of interest 4.5 Prepare checklists for observer score 4.6 Get landcover 4.7 Filter data for stats 4.8 Run observer expertise model 4.9 Write model to file 4.10 Get observer expertise as species in 60 mins 4.11 Write observer expertise to file", " Section 4 Prepare observer expertise 4.1 Prepare libraries # load libs library(data.table) library(readxl) library(magrittr) library(stringr) library(dplyr) library(tidyr) # get decimal time function library(lubridate) time_to_decimal &lt;- function(x) { x &lt;- hms(x, quiet = TRUE) hour(x) + minute(x) / 60 + second(x) / 3600 } 4.2 Prepare data Here, we go through the data preparation process again because we might want to assess observer expertise over a larger area than the study site. # read in shapefile of nilgiris to subset by bounding box library(sf) wg &lt;- st_read(&quot;data/spatial/hillsShapefile/Nil_Ana_Pal.shp&quot;); box &lt;- st_bbox(wg) # read in data and subset ebd &lt;- fread(&quot;ebd_Filtered_Jun2019.txt&quot;)[between(LONGITUDE, box[&quot;xmin&quot;], box[&quot;xmax&quot;]) &amp; between(LATITUDE, box[&quot;ymin&quot;], box[&quot;ymax&quot;]),][year(`OBSERVATION DATE`) &gt;= 2013,] # make new column names newNames &lt;- str_replace_all(colnames(ebd), &quot; &quot;, &quot;_&quot;) %&gt;% str_to_lower() setnames(ebd, newNames) # keep useful columns columnsOfInterest &lt;- c(&quot;checklist_id&quot;,&quot;scientific_name&quot;,&quot;observation_count&quot;,&quot;locality&quot;,&quot;locality_id&quot;,&quot;locality_type&quot;,&quot;latitude&quot;,&quot;longitude&quot;,&quot;observation_date&quot;,&quot;time_observations_started&quot;,&quot;observer_id&quot;,&quot;sampling_event_identifier&quot;,&quot;protocol_type&quot;,&quot;duration_minutes&quot;,&quot;effort_distance_km&quot;,&quot;effort_area_ha&quot;,&quot;number_observers&quot;,&quot;species_observed&quot;,&quot;reviewed&quot;,&quot;state_code&quot;, &quot;group_identifier&quot;) ebd &lt;- select(ebd, one_of(columnsOfInterest)) # get the checklist id as SEI or group id ebd[,checklist_id := ifelse(group_identifier == &quot;&quot;, sampling_event_identifier, group_identifier),] 4.3 Explicit spatial subset # get checklist locations ebd_locs &lt;- ebd[,.(longitude, latitude)] ebd_locs &lt;- setDF(ebd_locs) %&gt;% distinct(ebd_locs) ebd_locs &lt;- st_as_sf(ebd_locs, coords = c(&quot;longitude&quot;,&quot;latitude&quot;)) %&gt;% `st_crs&lt;-`(4326) %&gt;% mutate(id = 1:nrow(.)) # check whether to include to_keep &lt;- unlist(st_contains(wg, ebd_locs)) # filter locs ebd_locs &lt;- filter(ebd_locs, id %in% to_keep) %&gt;% bind_cols(as_tibble(st_coordinates(.))) %&gt;% st_drop_geometry() ebd &lt;- ebd[longitude %in% ebd_locs$X &amp; latitude %in% ebd_locs$Y,] 4.4 Prepare species of interest # read in species list specieslist = read_excel(path = &quot;data/species_list_13_11_2019.xlsx&quot;) # set species of interest soi = specieslist$scientific_name ebdSpSum &lt;- ebd[,.(nSp = .N, totSoiSeen = length(intersect(scientific_name, soi))), by = list(sampling_event_identifier)] # write to file and link with checklsit id later fwrite(ebdSpSum, file = &quot;data/dataChecklistSpecies.csv&quot;) 4.5 Prepare checklists for observer score # 1. add new columns of decimal time and julian date ebd[,`:=`(decimalTime = time_to_decimal(time_observations_started), julianDate = yday(as.POSIXct(observation_date)))] ebdEffChk &lt;- setDF(ebd) %&gt;% mutate(year = year(observation_date)) %&gt;% distinct(sampling_event_identifier, observer_id, year, duration_minutes, effort_distance_km, longitude, latitude, decimalTime, julianDate, number_observers) %&gt;% # drop rows with NAs in cols used in the model tidyr::drop_na(sampling_event_identifier, observer_id, duration_minutes, decimalTime, julianDate) %&gt;% # drop years below 2013 filter(year &gt;= 2013) # 3. join to covariates and remove large groups (&gt; 10) ebdChkSummary &lt;- inner_join(ebdEffChk, ebdSpSum) # remove ebird data rm(ebd); gc() 4.6 Get landcover Using the landcover 1km resolution here. # read in 1km landcover and set 0 to NA library(raster) landcover &lt;- raster::raster(&quot;data/spatial/landcover1km.tif&quot;) landcover[landcover==0] &lt;- NA # get locs in utm coords locs &lt;- distinct(ebdChkSummary, sampling_event_identifier, longitude, latitude) locs &lt;- st_as_sf(locs, coords = c(&quot;longitude&quot;, &quot;latitude&quot;)) %&gt;% `st_crs&lt;-`(4326) %&gt;% st_transform(32643) %&gt;% st_coordinates() # get for unique points landcoverVec &lt;- raster::extract(x = landcover, y = locs) # assign to df and overwrite setDT(ebdChkSummary)[,landcover:= landcoverVec] # save to file for later reuse fwrite(ebdChkSummary, file = &quot;data/eBirdChecklistVars.csv&quot;) 4.7 Filter data for stats # change names for easy handling setnames(ebdChkSummary, c(&quot;sei&quot;, &quot;observer&quot;,&quot;year&quot;, &quot;duration&quot;, &quot;distance&quot;, &quot;longitude&quot;, &quot;latitude&quot;, &quot;decimalTime&quot;, &quot;julianDate&quot;, &quot;nObs&quot;, &quot;nSp&quot;, &quot;nSoi&quot;, &quot;landcover&quot;)) # count data points per observer obscount &lt;- count(ebdChkSummary, observer) %&gt;% filter(n &gt;= 10) # make factor variables and remove obs not in obscount # also remove 0 durations ebdChkSummary &lt;- ebdChkSummary %&gt;% filter(observer %in% obscount$observer, duration &gt; 0, duration &lt;= 300, nSoi &gt; 0, !is.na(nSoi)) %&gt;% mutate(landcover = as.factor(landcover), observer = as.factor(observer)) %&gt;% drop_na(landcover) 4.8 Run observer expertise model Our observer expertise model aims to include the random intercpet effect of observer identity, with a random slope effect of duration. This models the different rate of species accumulation by different observers, as well as their different starting points. # uses either a subset or all data library(lmerTest) # here we specify a glmm with random effects for observer # time is considered a fixed log predictor and a random slope modObsExp &lt;- glmer(nSoi ~ sqrt(duration) + landcover+ sqrt(decimalTime) + I((sqrt(decimalTime))^2) + log(julianDate) + I((log(julianDate)^2)) + (1|observer) + (0+duration|observer), data = ebdChkSummary, family = &quot;poisson&quot;) 4.9 Write model to file # make dir if absent if(!dir.exists(&quot;data/modOutput&quot;)){ dir.create(&quot;data/modOutput&quot;) } # write model output to text file { writeLines(R.utils::captureOutput(list(Sys.time(), summary(modObsExp))), con = &quot;data/modOutput/modOutExpertise.txt&quot;) } 4.10 Get observer expertise as species in 60 mins # make df with means observer &lt;- unique(ebdChkSummary$observer) # predict at 60 mins on the most common landcover dfPredict &lt;- ebdChkSummary %&gt;% summarise_at(vars(duration, decimalTime, julianDate), list(~mean(.))) %&gt;% mutate(duration = 60, landcover = as.factor(6)) %&gt;% tidyr::crossing(observer) # run predict from model on it dfPredict &lt;- mutate(dfPredict, score = predict(modObsExp, newdata = dfPredict, type = &quot;response&quot;, allow.new.levels = TRUE)) %&gt;% mutate(score = scales::rescale(score)) 4.11 Write observer expertise to file fwrite(dfPredict %&gt;% dplyr::select(observer, score), file = &quot;data/dataObsExpScore.csv&quot;) "],
["add-covariates-to-subsampled-data.html", "Section 5 Add covariates to subsampled data 5.1 Prepare libraries and data 5.2 Subsample data 5.3 Add expertise score 5.4 Add landscape covariates 5.5 Construct buffers around subsampled points 5.6 Getting area means 5.7 Join landscape data to obs data 5.8 Write data to files", " Section 5 Add covariates to subsampled data 5.1 Prepare libraries and data # load libs library(dplyr); library(readr) library(stringr) library(purrr) library(raster) library(glue) library(velox) library(tidyr) library(sf) # load saved data object load(&quot;data_prelim_processing.rdata&quot;) 5.2 Subsample data Get 10 random (if available) observations of each species at each locality. Only 1000 samples used as an example. # subsample data for random 10 observations dataSubsample &lt;- dataGrouped %&gt;% plyr::dlply(c(&quot;scientific_name&quot;, &quot;locality_id&quot;)) %&gt;% # ugh this needs replaced because dlply is deprecated map_if(function(x) nrow(x) &gt; 10, function(x) sample_n(x, 10, replace = FALSE)) %&gt;% bind_rows() # remove full data rm(dataGrouped) 5.3 Add expertise score # read in obs score and extract numbers expertiseScore &lt;- read_csv(&quot;data/dataObsExpScore.csv&quot;) %&gt;% mutate(numObserver = str_extract(observer, &quot;\\\\d+&quot;)) %&gt;% dplyr::select(-observer) # group seis consist of multiple observers # in this case, seis need to have the highest expertise observer score # as the associated covariate # get unique observers per sei dataSeiScore &lt;- distinct(dataSubsample, sampling_event_identifier, observer_id) %&gt;% # make list column of observers mutate(observers = str_split(observer_id, &quot;,&quot;)) %&gt;% unnest(cols = c(observers)) %&gt;% # add numeric observer id mutate(numObserver = str_extract(observers, &quot;\\\\d+&quot;)) %&gt;% # now get distinct sei and observer id numeric distinct(sampling_event_identifier, numObserver) # now add expertise score to sei dataSeiScore &lt;- left_join(dataSeiScore, expertiseScore, by=&quot;numObserver&quot;) %&gt;% # get max expertise score per sei group_by(sampling_event_identifier) %&gt;% summarise(expertise = max(score)) # add to dataCovar dataSubsample &lt;- left_join(dataSubsample, dataSeiScore, by = &quot;sampling_event_identifier&quot;) # remove data without expertise score dataSubsample &lt;- filter(dataSubsample, !is.na(expertise)) 5.4 Add landscape covariates # list landscape covariate stacks landscape_files &lt;- &quot;data/spatial/landscape_resamp01km.tif&quot; # read in as stacks landscape_data &lt;- stack(landscape_files) # get proper names elev_names &lt;- c(&quot;elev&quot;, &quot;slope&quot;, &quot;aspect&quot;) chelsa_names &lt;- c(&quot;chelsa_bio10_04&quot;, &quot;chelsa_bio10_17&quot;, &quot;chelsa_bio10_18&quot;,&quot;chelsa_prec&quot;, &quot;chelsa_temp&quot;) names(landscape_data) &lt;- as.character(glue(&#39;{c(elev_names, chelsa_names, &quot;landcover&quot;)}&#39;)) 5.5 Construct buffers around subsampled points # assign neighbourhood radius in m sample_radius &lt;- c(2.5, 10, 25) * 1e3 # get distinct points and make buffer ebird_buff &lt;- dataSubsample %&gt;% distinct(latitude, longitude) %&gt;% mutate(id = 1:nrow(.)) %&gt;% crossing(sample_radius) %&gt;% arrange(id) %&gt;% group_by(sample_radius) %&gt;% nest() %&gt;% ungroup() # convert to spatial features ebird_buff &lt;- mutate(ebird_buff, data = map2(data, sample_radius, function(df,rd){ df_sf &lt;- st_as_sf(df, coords = c(&quot;longitude&quot;, &quot;latitude&quot;), crs = 4326) %&gt;% # add long lat bind_cols(as_tibble(st_coordinates(.))) %&gt;% rename(longitude = X, latitude = Y) %&gt;% # transform to modis projection st_transform(crs = 32643) %&gt;% # buffer to create neighborhood around each point st_buffer(dist = rd) })) 5.6 Getting area means 5.6.1 Mean environmental covariates All covariates are 2.5km mean values and prefixed “am_”. # get area mean for all preds except landcover, which is the last one env_area_mean &lt;- purrr::map(ebird_buff$data, function(df){ stk &lt;- landscape_data[[-dim(landscape_data)[3]]] # removing landcover here velstk &lt;- velox(stk) dextr &lt;- velstk$extract(sp = df, df = TRUE, fun = function(x)mean(x, na.rm=T)) # assign names for joining names(dextr) &lt;- c(&quot;id&quot;, names(stk)) return(as_tibble(dextr)) }) # join to buffer data ebird_buff &lt;- ebird_buff %&gt;% mutate(data = map2(data, env_area_mean, inner_join, by = &quot;id&quot;)) 5.6.2 Proportional landcover # get the last element of each stack from the list # this is the landcover at that resolution lc_area_prop &lt;- purrr::map(ebird_buff$data, function(df){ lc &lt;- landscape_data[[dim(landscape_data)[3]]] # accessing landcover here lc_velox &lt;- velox(lc) lc_vals &lt;- lc_velox$extract(sp = df, df = TRUE) names(lc_vals) &lt;- c(&quot;id&quot;, &quot;lc&quot;) # get landcover proportions lc_prop &lt;- count(lc_vals, id, lc) %&gt;% group_by(id) %&gt;% mutate(lc = glue(&#39;lc_{str_pad(lc, 2, pad = &quot;0&quot;)}&#39;), prop = n/sum(n)) %&gt;% dplyr::select(-n) %&gt;% tidyr::pivot_wider(names_from = lc, values_from = prop, values_fill = list(prop = 0)) %&gt;% ungroup() return(lc_prop) }) # join to data ebird_buff &lt;- ebird_buff %&gt;% mutate(data = map2(data, lc_area_prop, inner_join, by = &quot;id&quot;)) 5.7 Join landscape data to obs data # duplicate scale data data_at_scale &lt;- ebird_buff # join the full data to landscape samples at each scale data_at_scale$data &lt;- map(data_at_scale$data, function(df){ df &lt;- st_drop_geometry(df) df &lt;- inner_join(dataSubsample, df, by=c(&quot;longitude&quot;, &quot;latitude&quot;)) return(df) }) 5.8 Write data to files # write to file pmap(data_at_scale, function(sample_radius, data){ write_csv(data, path = glue(&#39;data/dataCovars_{str_pad(sample_radius/1e3, 2, pad = &quot;0&quot;)}km.csv&#39;)) return(&quot;export done&quot;) }) "],
["occupancy-modelling.html", "Section 6 Occupancy modelling 6.1 Load necessary libraries 6.2 Load dataframe and scale covariates 6.3 Identifying covariates necessary to model the detection process 6.4 Running a null model 6.5 Land Cover and Climate (effects modeled separately) 6.6 Elevation alone 6.7 The interaction between Land cover and elevation and climate and Elevation 6.8 The linear combined effect of land cover and climate 6.9 The interaction between inter-annual variation in temperature and land cover 6.10 The interaction between inter-annual variation in precip and land cover", " Section 6 Occupancy modelling 6.1 Load necessary libraries # Load libraries library(auk) library(lubridate) library(sf) library(unmarked) library(raster) library(ebirdst) library(MuMIn) library(AICcmodavg) library(fields) library(tidyverse) library(doParallel) library(snow) library(openxlsx) library(data.table) library(dplyr) 6.2 Load dataframe and scale covariates Here, we load the required dataframe that contains 10 random visits to a site. Please note that this process is repeated for each dataframe where environmental covariates were prepared at a spatial scale of 2.5, 10 and 25 sq.km around each unique locality. We also scaled all covariates (mean around 0 and standard deviation of 1) # Load in the prepared dataframe that contains 10 random visits to each site library(data.table) dat &lt;- fread(&quot;K:\\\\Chapter 2_Occupancy Modeling\\\\Data\\\\SpeciesCovariateData\\\\4_dataForOccu.csv&quot;,header=T) setDF(dat) head(dat) # Some more pre-processing to get the right data structures dat.1 &lt;- dat %&gt;% mutate(year = year(observation_date), pres_abs = as.integer(pres_abs)) # occupancy modeling requires an integer response # Scaling detection and occupancy covariates dat.scaled &lt;- dat.1 dat.scaled[,c(1,2,11,15,19:35)] &lt;- scale(dat.scaled[,c(1,2,11,15,19:35)]) # Scaling and standardizing detection and site-level covariates fwrite(dat.scaled, file = &quot;K:\\\\Chapter 2_Occupancy Modeling\\\\Data\\\\SpeciesCovariateData\\\\5_scaled_Covs.csv&quot;) 6.3 Identifying covariates necessary to model the detection process Here, we use the unmarked package in R (Fiske and Chandler 2019) to identify detection level covariates that are important for each species # All models are stored in lists below det_dred &lt;- list() # Subsetting those models whose deltaAIC&lt;4 (Burnham et al., 2011) top_det &lt;- list() # Getting model averaged coefficients and relative importance scores det_avg &lt;- list() det_imp &lt;- list() # Getting model estimates det_modelEst &lt;- list() # Add a progress bar for the loop pb &lt;- txtProgressBar(min = 0, max = length(unique(dat.scaled$scientific_name)), style = 3) #text based bar for(i in 1:length(unique(dat.scaled$scientific_name))){ data &lt;- dat.scaled %&gt;% filter(dat.scaled$scientific_name==unique(dat.scaled$scientific_name)[i]) # Preparing data for the unmarked model occ &lt;- filter_repeat_visits(data, min_obs = 1, max_obs = 10, annual_closure = FALSE, n_days = 2200, # 6 years is considered a period of closure date_var = &quot;observation_date&quot;, site_vars = c(&quot;locality_id&quot;)) obs_covs &lt;- c(&quot;min_obs_started&quot;, &quot;duration_minutes&quot;, &quot;effort_distance_km&quot;, &quot;number_observers&quot;, &quot;protocol_type&quot;, &quot;expertise&quot;, &quot;julian_date&quot;) # format for unmarked occ_wide &lt;- format_unmarked_occu(occ, site_id = &quot;site&quot;, response = &quot;pres_abs&quot;, site_covs = c( &quot;locality_id&quot;,&quot;lc_01.y&quot;,&quot;lc_02.y&quot;,&quot;lc_03.y&quot;, &quot;lc_04.y&quot;, &quot;lc_05.y&quot;, &quot;lc_06.y&quot;, &quot;lc_07.y&quot;,&quot;bio_4.y&quot;, &quot;bio_17.y&quot;,&quot;bio_18.y&quot;, &quot;prec_interannual.y&quot;,&quot;temp_interannual.y&quot;),obs_covs = obs_covs) # Convert this dataframe of observations into an unmarked object to start fitting occupancy models occ_um &lt;- formatWide(occ_wide, type = &quot;unmarkedFrameOccu&quot;) # Fit a global model with all detection level covariates global_mod &lt;- occu(~ min_obs_started+ julian_date + duration_minutes + effort_distance_km + number_observers + protocol_type + expertise ~ 1, data = occ_um) # Set up the cluster clusterType &lt;- if(length(find.package(&quot;snow&quot;, quiet = TRUE))) &quot;SOCK&quot; else &quot;PSOCK&quot; clust &lt;- try(makeCluster(getOption(&quot;cl.cores&quot;, 5), type = clusterType)) clusterEvalQ(clust, library(unmarked)) clusterExport(clust, &quot;occ_um&quot;) # Dredging the same det_dred[[i]] &lt;- pdredge(global_mod, clust) names(det_dred)[i] &lt;- unique(dat.scaled$scientific_name)[i] # Get the top models, which we&#39;ll define as those with deltaAICc &lt;4 top_det[[i]] &lt;- get.models(det_dred[[i]], subset = delta &lt; 4, cluster = clust) names(top_det)[i] &lt;- unique(dat.scaled$scientific_name)[i] # Obtaining model averaged coefficients if(length(top_det[[i]])&gt;1){ a &lt;- model.avg(top_det[[i]], fit = TRUE) det_avg[[i]] &lt;- as.data.frame(a$coefficients) names(det_avg)[i] &lt;- unique(dat.scaled$scientific_name)[i] det_modelEst[[i]] &lt;- data.frame(Predictor = rownames(coefTable(a, full = T)), Coefficient = coefTable(a, full = T)[,1], SE = coefTable(a, full = T)[,2], lowerCI = confint(a)[,1], upperCI = confint(a)[,2]) names(det_modelEst)[i] &lt;- unique(dat.scaled$scientific_name)[i] det_imp[[i]] &lt;- as.data.frame(MuMIn::importance(a)) names(det_imp)[i] &lt;- unique(dat.scaled$scientific_name)[i] } else { det_avg[[i]] &lt;- as.data.frame(unmarked::coef(top_det[[i]][[1]])) names(det_avg)[i] &lt;- unique(dat.scaled$scientific_name)[i] lowSt &lt;- data.frame(lowerCI=confint(top_det[[i]][[1]], type=&quot;state&quot;)[,1]) lowDet &lt;- data.frame(lowerCI=confint(top_det[[i]][[1]], type=&quot;det&quot;)[,1]) upSt &lt;- data.frame(upperCI=confint(top_det[[i]][[1]], type=&quot;state&quot;)[,2]) upDet &lt;- data.frame(upperCI=confint(top_det[[i]][[1]], type=&quot;det&quot;)[,2]) det_modelEst[[i]] &lt;- data.frame(Predictor = rownames(coefTable(top_det[[i]][[1]])), Coefficient = coefTable(top_det[[i]][[1]])[,1], SE = coefTable(top_det[[i]][[1]])[,2], lowerCI = rbind(lowSt,lowDet), upperCI = rbind(upSt,upDet)) names(det_modelEst)[i] &lt;- unique(dat.scaled$scientific_name)[i] } setTxtProgressBar(pb, i) stopCluster(clust) } close(pb) ## Storing output from the above models in excel sheets # 1. Store all the dredged model outputs for each species (variable: det_dred() - see above) write.xlsx(det_dred ,file=&quot;C:\\\\Users\\\\vr235\\\\Downloads\\\\det_dred.xlsx&quot;) # 2. Store all the model averaged outputs for each species and the relative importance score write.xlsx(det_avg, file = &quot;C:\\\\Users\\\\vr235\\\\Downloads\\\\det_avg.xlsx&quot;, rowNames=T, colNames=T) write.xlsx(det_imp, file = &quot;C:\\\\Users\\\\vr235\\\\Downloads\\\\det_imp.xlsx&quot;, rowNames=T, colNames=T) write.xlsx(det_modelEst, file = &quot;C:\\\\Users\\\\vr235\\\\Downloads\\\\det_modelEst.xlsx&quot;, rowNames=T, colNames=T) 6.4 Running a null model # All null models are stored in lists below all_null &lt;- list() # Add a progress bar for the loop pb &lt;- txtProgressBar(min = 0, max = length(unique(dat.1$scientific_name)), style = 3) #text based bar for(i in 1:length(unique(dat.scaled$scientific_name))){ data &lt;- dat.scaled %&gt;% filter(dat.scaled$scientific_name==unique(dat.scaled$scientific_name)[i]) # Preparing data for the unmarked model occ &lt;- filter_repeat_visits(data, min_obs = 1, max_obs = 10, annual_closure = FALSE, n_days = 2200, # 6 years is considered a period of closure date_var = &quot;observation_date&quot;, site_vars = c(&quot;locality_id&quot;)) obs_covs &lt;- c(&quot;min_obs_started&quot;, &quot;duration_minutes&quot;, &quot;effort_distance_km&quot;, &quot;number_observers&quot;, &quot;protocol_type&quot;, &quot;expertise&quot;, &quot;julian_date&quot;) # format for unmarked occ_wide &lt;- format_unmarked_occu(occ, site_id = &quot;site&quot;, response = &quot;pres_abs&quot;, site_covs = c( &quot;locality_id&quot;,&quot;lc_01.y&quot;,&quot;lc_02.y&quot;,&quot;lc_03.y&quot;, &quot;lc_04.y&quot;, &quot;lc_05.y&quot;, &quot;lc_06.y&quot;, &quot;lc_07.y&quot;,&quot;bio_4.y&quot;, &quot;bio_17.y&quot;,&quot;bio_18.y&quot;, &quot;prec_interannual.y&quot;,&quot;temp_interannual.y&quot;, &quot;alt.y&quot;,&quot;slope.y&quot;), obs_covs = obs_covs) # Convert this dataframe of observations into an unmarked object to start fitting occupancy models occ_um &lt;- formatWide(occ_wide, type = &quot;unmarkedFrameOccu&quot;) # Set up the model all_null[[i]] &lt;- occu(~1~1, data = occ_um) names(all_null)[i] &lt;- unique(dat.scaled$scientific_name)[i] setTxtProgressBar(pb, i) } close(pb) # Store all the model outputs for each species capture.output(all_null ,file=&quot;C:\\\\Users\\\\vr235\\\\Downloads\\\\null_models.csv&quot;) 6.5 Land Cover and Climate (effects modeled separately) # All dredged models are stored in lists below landcover &lt;- list() climate &lt;- list() # Subsetting those models whose deltaAIC&lt;4 (Burnham et al., 2011) top_lc &lt;- list() top_clim &lt;- list() # Getting model averaged coefficients and relative importance scores lc_avg &lt;- list() clim_avg &lt;- list() lc_imp &lt;- list() clim_imp &lt;- list() # Storing Model estimates lc_modelEst &lt;- list() clim_modelEst &lt;- list() # Add a progress bar for the loop pb &lt;- txtProgressBar(min = 0, max = length(unique(dat.scaled$scientific_name)), style = 3) #text based bar for(i in 1:length(unique(dat.scaled$scientific_name))){ data &lt;- dat.scaled %&gt;% filter(dat.scaled$scientific_name==unique(dat.scaled$scientific_name)[i]) # Preparing data for the unmarked model occ &lt;- filter_repeat_visits(data, min_obs = 1, max_obs = 10, annual_closure = FALSE, n_days = 2200, # 6 years is considered a period of closure date_var = &quot;observation_date&quot;, site_vars = c(&quot;locality_id&quot;)) obs_covs &lt;- c(&quot;min_obs_started&quot;, &quot;duration_minutes&quot;, &quot;effort_distance_km&quot;, &quot;number_observers&quot;, &quot;protocol_type&quot;, &quot;expertise&quot;, &quot;julian_date&quot;) # format for unmarked occ_wide &lt;- format_unmarked_occu(occ, site_id = &quot;site&quot;, response = &quot;pres_abs&quot;, site_covs = c( &quot;locality_id&quot;,&quot;lc_01.y&quot;,&quot;lc_02.y&quot;,&quot;lc_03.y&quot;, &quot;lc_04.y&quot;, &quot;lc_05.y&quot;, &quot;lc_06.y&quot;, &quot;lc_07.y&quot;,&quot;bio_4.y&quot;, &quot;bio_17.y&quot;,&quot;bio_18.y&quot;, &quot;prec_interannual.y&quot;,&quot;temp_interannual.y&quot; ), obs_covs = obs_covs) # Convert this dataframe of observations into an unmarked object to start fitting occupancy models occ_um &lt;- formatWide(occ_wide, type = &quot;unmarkedFrameOccu&quot;) # Subset 1: Keep all land cover predictors model_lc &lt;- occu(~min_obs_started+ julian_date + duration_minutes + effort_distance_km + number_observers + protocol_type + expertise~lc_01.y+lc_02.y+lc_03.y+ lc_04.y+ lc_05.y+ lc_06.y+ lc_07.y, data = occ_um) # Subset 2: Keep all climate associated predictors model_clim &lt;- occu(~min_obs_started+ julian_date + duration_minutes + effort_distance_km + number_observers + protocol_type + expertise~bio_4.y + bio_17.y + bio_18.y + prec_interannual.y + temp_interannual.y, data = occ_um) # Set up the cluster clusterType &lt;- if(length(find.package(&quot;snow&quot;, quiet = TRUE))) &quot;SOCK&quot; else &quot;PSOCK&quot; clust &lt;- try(makeCluster(getOption(&quot;cl.cores&quot;, 6), type = clusterType)) clusterEvalQ(clust, library(unmarked)) clusterExport(clust, &quot;occ_um&quot;) # Detection terms are fixed det_terms &lt;- c(&quot;p(duration_minutes)&quot;,&quot;p(effort_distance_km)&quot;, &quot;p(expertise)&quot;,&quot;p(julian_date)&quot;,&quot;p(min_obs_started)&quot;, &quot;p(number_observers)&quot;,&quot;p(protocol_type)&quot;) # Dredging landcover[[i]] &lt;- pdredge(model_lc, clust, fixed=det_terms) climate[[i]] &lt;- pdredge(model_clim, clust, fixed = det_terms) names(landcover)[i] &lt;- unique(dat.scaled$scientific_name)[i] names(climate)[i] &lt;- unique(dat.scaled$scientific_name)[i] # Identiying top subset of models based on deltaAIC scores being less than 4 (Burnham et al., 2011) top_lc[[i]] &lt;- get.models(landcover[[i]], subset = delta&lt;4, cluster = clust) top_clim[[i]] &lt;- get.models(climate[[i]], subset = delta &lt;4, cluster = clust) names(top_lc)[i] &lt;- unique(dat.scaled$scientific_name)[i] names(top_clim)[i] &lt;- unique(dat.scaled$scientific_name)[i] # Obtaining model averaged coefficients for both candidate model subsets if(length(top_lc[[i]])&gt;1){ a &lt;- model.avg(top_lc[[i]], fit = TRUE) lc_avg[[i]] &lt;- as.data.frame(a$coefficients) names(lc_avg)[i] &lt;- unique(dat.scaled$scientific_name)[i] lc_modelEst[[i]] &lt;- data.frame(Predictor = rownames(coefTable(a, full = T)), Coefficient = coefTable(a, full = T)[,1], SE = coefTable(a, full = T)[,2], lowerCI = confint(a)[,1], upperCI = confint(a)[,2]) names(lc_modelEst)[i] &lt;- unique(dat.scaled$scientific_name)[i] lc_imp[[i]] &lt;- as.data.frame(MuMIn::importance(a)) names(lc_imp)[i] &lt;- unique(dat.scaled$scientific_name)[i] } else { lc_avg[[i]] &lt;- as.data.frame(unmarked::coef(top_lc[[i]][[1]])) names(lc_avg)[i] &lt;- unique(dat.scaled$scientific_name)[i] lowSt &lt;- data.frame(lowerCI=confint(top_lc[[i]][[1]], type=&quot;state&quot;)[,1]) lowDet &lt;- data.frame(lowerCI=confint(top_lc[[i]][[1]], type=&quot;det&quot;)[,1]) upSt &lt;- data.frame(upperCI=confint(top_lc[[i]][[1]], type=&quot;state&quot;)[,2]) upDet &lt;- data.frame(upperCI=confint(top_lc[[i]][[1]], type=&quot;det&quot;)[,2]) lc_modelEst[[i]] &lt;- data.frame(Predictor = rownames(coefTable(top_lc[[i]][[1]])), Coefficient = coefTable(top_lc[[i]][[1]])[,1], SE = coefTable(top_lc[[i]][[1]])[,2], lowerCI = rbind(lowSt,lowDet), upperCI = rbind(upSt,upDet)) names(lc_modelEst)[i] &lt;- unique(dat.scaled$scientific_name)[i] } if(length(top_clim[[i]])&gt;1){ b &lt;- model.avg(top_clim[[i]], fit = TRUE) clim_avg[[i]] &lt;- as.data.frame(b$coefficients) names(clim_avg)[i] &lt;- unique(dat.scaled$scientific_name)[i] clim_modelEst[[i]] &lt;- data.frame(Predictor = rownames(coefTable(b, full = T)), Coefficient = coefTable(b, full = T)[,1], SE = coefTable(b, full = T)[,2], lowerCI = confint(b)[,1], upperCI = confint(b)[,2]) names(clim_modelEst)[i] &lt;- unique(dat.scaled$scientific_name)[i] clim_imp[[i]] &lt;- as.data.frame(MuMIn::importance(b)) names(clim_imp)[i] &lt;- unique(dat.scaled$scientific_name)[i] } else { clim_avg[[i]] &lt;- as.data.frame(unmarked::coef(top_clim[[i]][[1]])) names(clim_avg)[i] &lt;- unique(dat.scaled$scientific_name)[i] lowSt &lt;- data.frame(lowerCI=confint(top_clim[[i]][[1]], type=&quot;state&quot;)[,1]) lowDet &lt;- data.frame(lowerCI=confint(top_clim[[i]][[1]], type=&quot;det&quot;)[,1]) upSt &lt;- data.frame(upperCI=confint(top_clim[[i]][[1]], type=&quot;state&quot;)[,2]) upDet &lt;- data.frame(upperCI=confint(top_clim[[i]][[1]], type=&quot;det&quot;)[,2]) clim_modelEst[[i]] &lt;- data.frame(Predictor = rownames(coefTable(top_clim[[i]][[1]])), Coefficient = coefTable(top_clim[[i]][[1]])[,1], SE = coefTable(top_clim[[i]][[1]])[,2], lowerCI = rbind(lowSt,lowDet), upperCI = rbind(upSt,upDet)) names(clim_modelEst)[i] &lt;- unique(dat.scaled$scientific_name)[i] } setTxtProgressBar(pb, i) stopCluster(clust) } close(pb) # 1. Store all the dredged model outputs for each species (for both landcover and climate) write.xlsx(landcover ,file=&quot;C:\\\\Users\\\\vr235\\\\Downloads\\\\landCover.xlsx&quot;) write.xlsx(climate, file = &quot;C:\\\\Users\\\\vr235\\\\Downloads\\\\climate.xlsx&quot;) # 2. Store all the model averaged outputs for each species and relative importance scores write.xlsx(lc_avg, file = &quot;C:\\\\Users\\\\vr235\\\\Downloads\\\\lc_avg.xlsx&quot;, rowNames=T, colNames=T) write.xlsx(clim_avg, file = &quot;C:\\\\Users\\\\vr235\\\\Downloads\\\\clim_avg.xlsx&quot;, rowNames=T, colNames=T) write.xlsx(lc_imp, file = &quot;C:\\\\Users\\\\vr235\\\\Downloads\\\\lc_imp.xlsx&quot;, rowNames=T, colNames=T) write.xlsx(clim_imp, file = &quot;C:\\\\Users\\\\vr235\\\\Downloads\\\\clim_imp.xlsx&quot;, rowNames=T, colNames=T) # 3. Store all model estimates write.xlsx(lc_modelEst, file = &quot;C:\\\\Users\\\\vr235\\\\Downloads\\\\lc_modelEst.xlsx&quot;, rowNames=T, colNames=T) write.xlsx(clim_modelEst, file = &quot;C:\\\\Users\\\\vr235\\\\Downloads\\\\clim_modelEst.xlsx&quot;, rowNames=T, colNames=T) 6.6 Elevation alone dat.scaled &lt;- fread(&quot;K:\\\\Chapter 2_Occupancy Modeling\\\\Data\\\\SpeciesCovariateData\\\\5_scaled_Covs.csv&quot;, header=T) setDF(dat.scaled) head(dat.scaled) # All dredged models are stored in lists below elev &lt;- list() # Subsetting those models whose deltaAIC&lt;4 (Burnham et al., 2011) top_elev &lt;- list() # Getting model averaged coefficients and their importance (see MuMIN::importance()) elev_avg &lt;- list() elev_imp &lt;- list() # Get all model related estimates modelEst &lt;- list() # Add a progress bar for the loop pb &lt;- txtProgressBar(min = 0, max = length(unique(dat.scaled$scientific_name)), style = 3) #text based bar for(i in 1:length(unique(dat.scaled$scientific_name))){ data &lt;- dat.scaled %&gt;% filter(dat.scaled$scientific_name==unique(dat.scaled$scientific_name)[35]) # Preparing data for the unmarked model occ &lt;- filter_repeat_visits(data, min_obs = 1, max_obs = 10, annual_closure = FALSE, n_days = 2200, # 6 years is considered a period of closure date_var = &quot;observation_date&quot;, site_vars = c(&quot;locality_id&quot;)) obs_covs &lt;- c(&quot;min_obs_started&quot;, &quot;duration_minutes&quot;, &quot;effort_distance_km&quot;, &quot;number_observers&quot;, &quot;protocol_type&quot;, &quot;expertise&quot;, &quot;julian_date&quot;) # format for unmarked occ_wide &lt;- format_unmarked_occu(occ, site_id = &quot;site&quot;, response = &quot;pres_abs&quot;, site_covs = c( &quot;alt.y&quot;,&quot;aspect.y&quot;,&quot;slope.y&quot;), obs_covs = obs_covs) # Convert this dataframe of observations into an unmarked object to start fitting occupancy models occ_um &lt;- formatWide(occ_wide, type = &quot;unmarkedFrameOccu&quot;) # Subset - Using all elevation predictors model_elev &lt;- occu(~min_obs_started+ julian_date + duration_minutes + effort_distance_km + number_observers + protocol_type + expertise~alt.y + slope.y +aspect.y , data = occ_um) # Set up the cluster clusterType &lt;- if(length(find.package(&quot;snow&quot;, quiet = TRUE))) &quot;SOCK&quot; else &quot;PSOCK&quot; clust &lt;- try(makeCluster(getOption(&quot;cl.cores&quot;, 5), type = clusterType)) clusterEvalQ(clust, library(unmarked)) clusterExport(clust, &quot;occ_um&quot;) # Detection terms are fixed det_terms &lt;- c(&quot;p(duration_minutes)&quot;,&quot;p(effort_distance_km)&quot;, &quot;p(expertise)&quot;,&quot;p(julian_date)&quot;,&quot;p(min_obs_started)&quot;, &quot;p(number_observers)&quot;,&quot;p(protocol_type)&quot;) # Dredging elev[[i]] &lt;- pdredge(model_elev, clust, fixed=det_terms) names(elev)[i] &lt;- unique(dat.scaled$scientific_name)[i] # Identiying top subset of models based on deltaAIC scores being less than 4 (Burnham et al., 2011) top_elev[[i]] &lt;- get.models(elev[[i]], subset = delta&lt;4, cluster = clust) names(top_elev)[i] &lt;- unique(dat.scaled$scientific_name)[i] # Obtaining model averaged coefficients for candidate model subsets and importance if(length(top_elev[[i]])&gt;1){ a &lt;- model.avg(top_elev[[i]], fit = TRUE) elev_avg[[i]] &lt;- as.data.frame(a$coefficients) names(elev_avg)[i] &lt;- unique(dat.scaled$scientific_name)[i] modelEst[[i]] &lt;- data.frame(Predictor = rownames(coefTable(a, full = T)), Coefficient = coefTable(a, full = T)[,1], SE = coefTable(a, full = T)[,2], lowerCI = confint(a)[,1], upperCI = confint(a)[,2]) names(modelEst)[i] &lt;- unique(dat.scaled$scientific_name)[i] elev_imp[[i]] &lt;- as.data.frame(MuMIn::importance(a)) names(elev_imp)[i] &lt;- unique(dat.scaled$scientific_name)[i] } else { elev_avg[[i]] &lt;- as.data.frame(unmarked::coef(top_elev[[i]][[1]])) names(elev_avg)[i] &lt;- unique(dat.scaled$scientific_name)[i] lowSt &lt;- data.frame(lowerCI=confint(top_elev[[i]][[1]], type=&quot;state&quot;)[,1]) lowDet &lt;- data.frame(lowerCI=confint(top_elev[[i]][[1]], type=&quot;det&quot;)[,1]) upSt &lt;- data.frame(upperCI=confint(top_elev[[i]][[1]], type=&quot;state&quot;)[,2]) upDet &lt;- data.frame(upperCI=confint(top_elev[[i]][[1]], type=&quot;det&quot;)[,2]) modelEst[[i]] &lt;- data.frame(Predictor = rownames(coefTable(top_elev[[i]][[1]])), Coefficient = coefTable(top_elev[[i]][[1]])[,1], SE = coefTable(top_elev[[i]][[1]])[,2], lowerCI = rbind(lowSt,lowDet), upperCI = rbind(upSt,upDet)) names(modelEst)[i] &lt;- unique(dat.scaled$scientific_name)[i] } setTxtProgressBar(pb, i) stopCluster(clust) } close(pb) # 1. Store all the dredged model outputs for each species write.xlsx(elev ,file=&quot;C:\\\\Users\\\\vr235\\\\Downloads\\\\elev.xlsx&quot;) # 2. Store all the model averaged outputs for each species and the importance score write.xlsx(elev_avg, file = &quot;C:\\\\Users\\\\vr235\\\\Downloads\\\\elev_avg.xlsx&quot;, rowNames=T, colNames=T) write.xlsx(elev_imp, file = &quot;C:\\\\Users\\\\vr235\\\\Downloads\\\\elev_imp.xlsx&quot;, rowNames=T, colNames=T) # 3. Store all model estimates write.xlsx(modelEst, file = &quot;C:\\\\Users\\\\vr235\\\\Downloads\\\\modelEst.xlsx&quot;, rowNames=T, colNames=T) 6.7 The interaction between Land cover and elevation and climate and Elevation # Q2: How does elevation influence the relative importance of land cover vs climate associated predictors in structuring the probability of occupancy? #### Candidate sets: lc1 | prop. of grasslands, forests, tea and plantations; elev #### lc2 | prop. of agriculture, settlements, waterbodies; elev #### clim | bio_4, bio_17, precip, bio_18; elev dat.scaled &lt;- fread(&quot;K:\\\\Chapter 2_Occupancy Modeling\\\\Data\\\\SpeciesCovariateData\\\\5_scaled_Covs.csv&quot;, header=T) setDF(dat.scaled) head(dat.scaled) # All dredged models are stored in lists below lc1_elev &lt;- list() lc2_elev &lt;- list() clim_elev &lt;- list() # Subsetting those models whose deltaAIC&lt;4 (Burnham et al., 2011) top_lc1_elev &lt;- list() top_lc2_elev &lt;- list() top_clim_elev &lt;- list() # Getting model averaged coefficients lc1_elev_avg &lt;- list() lc2_elev_avg &lt;- list() clim_elev_avg &lt;- list() lc1_elev_imp &lt;- list() lc2_elev_imp &lt;- list() clim_elev_imp &lt;- list() # Get model estimates lc1_modelEst &lt;- list() lc2_modelEst &lt;- list() clim_modelEst &lt;- list() # Add a progress bar for the loop pb &lt;- txtProgressBar(min = 0, max = length(unique(dat.scaled$scientific_name)), style = 3) #text based bar for(i in 1:length(unique(dat.scaled$scientific_name))){ data &lt;- dat.scaled %&gt;% filter(dat.scaled$scientific_name==unique(dat.scaled$scientific_name)[i]) # Preparing data for the unmarked model occ &lt;- filter_repeat_visits(data, min_obs = 1, max_obs = 10, annual_closure = FALSE, n_days = 2200, # 6 years is considered a period of closure date_var = &quot;observation_date&quot;, site_vars = c(&quot;locality_id&quot;)) obs_covs &lt;- c(&quot;min_obs_started&quot;, &quot;duration_minutes&quot;, &quot;effort_distance_km&quot;, &quot;number_observers&quot;, &quot;protocol_type&quot;, &quot;expertise&quot;, &quot;julian_date&quot;) # format for unmarked occ_wide &lt;- format_unmarked_occu(occ, site_id = &quot;site&quot;, response = &quot;pres_abs&quot;, site_covs = c( &quot;locality_id&quot;,&quot;lc_01.y&quot;,&quot;lc_02.y&quot;,&quot;lc_03.y&quot;, &quot;lc_04.y&quot;, &quot;lc_05.y&quot;, &quot;lc_06.y&quot;, &quot;lc_07.y&quot;,&quot;bio_4.y&quot;, &quot;bio_17.y&quot;,&quot;bio_18.y&quot;, &quot;prec_interannual.y&quot;,&quot;alt.y&quot;), obs_covs = obs_covs) # Convert this dataframe of observations into an unmarked object to start fitting occupancy models occ_um &lt;- formatWide(occ_wide, type = &quot;unmarkedFrameOccu&quot;) # Subset 1: Keep all land cover predictors associated with grasslands, forests, plantations and tea model_lc1 &lt;- occu(~min_obs_started+ julian_date + duration_minutes + effort_distance_km + number_observers + protocol_type + expertise~lc_02.y*alt.y+lc_03.y*alt.y+ lc_04.y*alt.y+ lc_06.y*alt.y, data = occ_um) # Subset 2: Keep all land cover predictors associated with agriculture, settlements and waterbodies model_lc2 &lt;- occu(~min_obs_started+ julian_date + duration_minutes + effort_distance_km + number_observers + protocol_type + expertise~lc_01.y*alt.y+lc_05.y*alt.y+ lc_07.y*alt.y, data = occ_um) # Subset 3: Keep climate associated predictors (bio_4,bio_17,bio_18,prec_interannual) model_clim &lt;- occu(~min_obs_started+ julian_date + duration_minutes + effort_distance_km + number_observers + protocol_type + expertise~bio_4.y*alt.y + bio_17.y*alt.y + bio_18.y*alt.y + prec_interannual.y*alt.y, data = occ_um) # Set up the cluster clusterType &lt;- if(length(find.package(&quot;snow&quot;, quiet = TRUE))) &quot;SOCK&quot; else &quot;PSOCK&quot; clust &lt;- try(makeCluster(getOption(&quot;cl.cores&quot;, 6), type = clusterType)) clusterEvalQ(clust, library(unmarked)) clusterExport(clust, &quot;occ_um&quot;) # Detection terms are fixed det_terms &lt;- c(&quot;p(duration_minutes)&quot;,&quot;p(effort_distance_km)&quot;, &quot;p(expertise)&quot;,&quot;p(julian_date)&quot;,&quot;p(min_obs_started)&quot;, &quot;p(number_observers)&quot;,&quot;p(protocol_type)&quot;) # Dredging lc1_elev[[i]] &lt;- pdredge(model_lc1, clust, fixed=det_terms) lc2_elev[[i]] &lt;- pdredge(model_lc2, clust, fixed=det_terms) clim_elev[[i]] &lt;- pdredge(model_clim, clust, fixed = det_terms) names(lc1_elev)[i] &lt;- unique(dat.scaled$scientific_name)[i] names(lc2_elev)[i] &lt;- unique(dat.scaled$scientific_name)[i] names(clim_elev)[i] &lt;- unique(dat.scaled$scientific_name)[i] # Identiying top subset of models based on deltaAIC scores being less than 4 (Burnham et al., 2011) top_lc1_elev[[i]] &lt;- get.models(lc1_elev[[i]], subset = delta&lt;4, cluster = clust) top_lc2_elev[[i]] &lt;- get.models(lc2_elev[[i]], subset = delta&lt;4, cluster = clust) top_clim_elev[[i]] &lt;- get.models(clim_elev[[i]], subset = delta &lt;4, cluster = clust) names(top_lc1_elev)[i] &lt;- unique(dat.scaled$scientific_name)[i] names(top_lc2_elev)[i] &lt;- unique(dat.scaled$scientific_name)[i] names(top_clim_elev)[i] &lt;- unique(dat.scaled$scientific_name)[i] # Obtaining model averaged coefficients for both candidate model subsets if(length(top_lc1_elev[[i]])&gt;1){ a &lt;- model.avg(top_lc1_elev[[i]], fit = TRUE) lc1_elev_avg[[i]] &lt;- as.data.frame(a$coefficients) names(lc1_elev_avg)[i] &lt;- unique(dat.scaled$scientific_name)[i] lc1_modelEst[[i]] &lt;- data.frame(Predictor = rownames(coefTable(a, full = T)), Coefficient = coefTable(a, full = T)[,1], SE = coefTable(a, full = T)[,2], lowerCI = confint(a)[,1], upperCI = confint(a)[,2]) names(lc1_modelEst)[i] &lt;- unique(dat.scaled$scientific_name)[i] lc1_elev_imp[[i]] &lt;- as.data.frame(MuMIn::importance(a)) names(lc1_elev_imp)[i] &lt;- unique(dat.scaled$scientific_name)[i] } else { lc1_elev_avg[[i]] &lt;- as.data.frame(unmarked::coef(top_lc1_elev[[i]][[1]])) names(lc1_elev_avg)[i] &lt;- unique(dat.scaled$scientific_name)[i] lowSt &lt;- data.frame(lowerCI=confint(top_lc1_elev[[i]][[1]], type=&quot;state&quot;)[,1]) lowDet &lt;- data.frame(lowerCI=confint(top_lc1_elev[[i]][[1]], type=&quot;det&quot;)[,1]) upSt &lt;- data.frame(upperCI=confint(top_lc1_elev[[i]][[1]], type=&quot;state&quot;)[,2]) upDet &lt;- data.frame(upperCI=confint(top_lc1_elev[[i]][[1]], type=&quot;det&quot;)[,2]) lc1_modelEst[[i]] &lt;- data.frame(Predictor = rownames(coefTable(top_lc1_elev[[i]][[1]])), Coefficient = coefTable(top_lc1_elev[[i]][[1]])[,1], SE = coefTable(top_lc1_elev[[i]][[1]])[,2], lowerCI = rbind(lowSt,lowDet), upperCI = rbind(upSt,upDet)) names(lc1_modelEst)[i] &lt;- unique(dat.scaled$scientific_name)[i] } if(length(top_lc2_elev[[i]])&gt;1){ b &lt;- model.avg(top_lc2_elev[[i]], fit = TRUE) lc2_elev_avg[[i]] &lt;- as.data.frame(b$coefficients) names(lc2_elev_avg)[i] &lt;- unique(dat.scaled$scientific_name)[i] lc2_modelEst[[i]] &lt;- data.frame(Predictor = rownames(coefTable(b, full = T)), Coefficient = coefTable(b, full = T)[,1], SE = coefTable(b, full = T)[,2], lowerCI = confint(b)[,1], upperCI = confint(b)[,2]) names(lc2_modelEst)[i] &lt;- unique(dat.scaled$scientific_name)[i] lc2_elev_imp[[i]] &lt;- as.data.frame(MuMIn::importance(b)) names(lc2_elev_imp)[i] &lt;- unique(dat.scaled$scientific_name)[i] } else { lc2_elev_avg[[i]] &lt;- as.data.frame(unmarked::coef(top_lc2_elev[[i]][[1]])) names(lc2_elev_avg)[i] &lt;- unique(dat.scaled$scientific_name)[i] lowSt &lt;- data.frame(lowerCI=confint(top_lc2_elev[[i]][[1]], type=&quot;state&quot;)[,1]) lowDet &lt;- data.frame(lowerCI=confint(top_lc2_elev[[i]][[1]], type=&quot;det&quot;)[,1]) upSt &lt;- data.frame(upperCI=confint(top_lc2_elev[[i]][[1]], type=&quot;state&quot;)[,2]) upDet &lt;- data.frame(upperCI=confint(top_lc2_elev[[i]][[1]], type=&quot;det&quot;)[,2]) lc2_modelEst[[i]] &lt;- data.frame(Predictor = rownames(coefTable(top_lc2_elev[[i]][[1]])), Coefficient = coefTable(top_lc2_elev[[i]][[1]])[,1], SE = coefTable(top_lc2_elev[[i]][[1]])[,2], lowerCI = rbind(lowSt,lowDet), upperCI = rbind(upSt,upDet)) names(lc2_modelEst)[i] &lt;- unique(dat.scaled$scientific_name)[i] } if(length(top_clim_elev[[i]])&gt;1){ c &lt;- model.avg(top_clim_elev[[i]], fit = TRUE) clim_elev_avg[[i]] &lt;- as.data.frame(c$coefficients) names(clim_elev_avg)[i] &lt;- unique(dat.scaled$scientific_name)[i] clim_modelEst[[i]] &lt;- data.frame(Predictor = rownames(coefTable(c, full = T)), Coefficient = coefTable(c, full = T)[,1], SE = coefTable(c, full = T)[,2], lowerCI = confint(c)[,1], upperCI = confint(c)[,2]) names(clim_modelEst)[i] &lt;- unique(dat.scaled$scientific_name)[i] clim_elev_imp[[i]] &lt;- as.data.frame(MuMIn::importance(c)) names(clim_elev_imp)[i] &lt;- unique(dat.scaled$scientific_name)[i] } else { clim_elev_avg[[i]] &lt;- as.data.frame(unmarked::coef(top_clim_elev[[i]][[1]])) names(clim_elev_avg)[i] &lt;- unique(dat.scaled$scientific_name)[i] lowSt &lt;- data.frame(lowerCI=confint(top_clim_elev[[i]][[1]], type=&quot;state&quot;)[,1]) lowDet &lt;- data.frame(lowerCI=confint(top_clim_elev[[i]][[1]], type=&quot;det&quot;)[,1]) upSt &lt;- data.frame(upperCI=confint(top_clim_elev[[i]][[1]], type=&quot;state&quot;)[,2]) upDet &lt;- data.frame(upperCI=confint(top_clim_elev[[i]][[1]], type=&quot;det&quot;)[,2]) clim_modelEst[[i]] &lt;- data.frame(Predictor = rownames(coefTable(top_clim_elev[[i]][[1]])), Coefficient = coefTable(top_clim_elev[[i]][[1]])[,1], SE = coefTable(top_clim_elev[[i]][[1]])[,2], lowerCI = rbind(lowSt,lowDet), upperCI = rbind(upSt,upDet)) names(clim_modelEst)[i] &lt;- unique(dat.scaled$scientific_name)[i] } setTxtProgressBar(pb, i) stopCluster(clust) } close(pb) # 1. Store all the dredged model outputs for each species (for lc1_elev, lc2_elev and clim_elev) write.xlsx(lc1_elev ,file=&quot;C:\\\\Users\\\\vr235\\\\Downloads\\\\lc1_elev.xlsx&quot;) write.xlsx(lc2_elev ,file=&quot;C:\\\\Users\\\\vr235\\\\Downloads\\\\lc2_elev.xlsx&quot;) write.xlsx(clim_elev, file = &quot;C:\\\\Users\\\\vr235\\\\Downloads\\\\clim_elev.xlsx&quot;) # 2. Store all the model averaged outputs for each species and the relative importance score write.xlsx(lc1_elev_avg, file = &quot;C:\\\\Users\\\\vr235\\\\Downloads\\\\lc1_elev_avg.xlsx&quot;, rowNames=T, colNames=T) write.xlsx(lc2_elev_avg, file = &quot;C:\\\\Users\\\\vr235\\\\Downloads\\\\lc2_elev_avg.xlsx&quot;, rowNames=T, colNames=T) write.xlsx(clim_elev_avg, file = &quot;C:\\\\Users\\\\vr235\\\\Downloads\\\\clim_elev_avg.xlsx&quot;, rowNames=T, colNames=T) write.xlsx(lc1_elev_imp, file = &quot;C:\\\\Users\\\\vr235\\\\Downloads\\\\lc1_elev_imp.xlsx&quot;, rowNames=T, colNames=T) write.xlsx(lc2_elev_imp, file = &quot;C:\\\\Users\\\\vr235\\\\Downloads\\\\lc2_elev_imp.xlsx&quot;, rowNames=T, colNames=T) write.xlsx(clim_elev_imp, file = &quot;C:\\\\Users\\\\vr235\\\\Downloads\\\\clim_elev_imp.xlsx&quot;, rowNames=T, colNames=T) write.xlsx(lc1_modelEst, file = &quot;C:\\\\Users\\\\vr235\\\\Downloads\\\\lc1_modelEst.xlsx&quot;, rowNames=T, colNames=T) write.xlsx(lc2_modelEst, file = &quot;C:\\\\Users\\\\vr235\\\\Downloads\\\\lc2_modelEst.xlsx&quot;, rowNames=T, colNames=T) write.xlsx(clim_modelEst, file = &quot;C:\\\\Users\\\\vr235\\\\Downloads\\\\clim_modelEst.xlsx&quot;, rowNames=T, colNames=T) 6.8 The linear combined effect of land cover and climate #### Using lc predictors: lc1, lc2, lc3,lc4,lc5,lc6 #### Using climate predictors: temp_interannual and precip_interannual dat.scaled &lt;- fread(&quot;K:\\\\Chapter 2_Occupancy Modeling\\\\Data\\\\SpeciesCovariateData\\\\5_scaled_Covs.csv&quot;,header=T) setDF(dat.scaled) head(dat.scaled) # All dredged models are stored in lists below lc_clim &lt;- list() # Subsetting those models whose deltaAIC&lt;4 (Burnham et al., 2011) top_lc_clim &lt;- list() # Getting model averaged coefficients lc_clim_avg &lt;- list() lc_clim_imp &lt;- list() # Getting model estimates lc_clim_modelEst &lt;- list() # Add a progress bar for the loop pb &lt;- txtProgressBar(min = 0, max = length(unique(dat.scaled$scientific_name)), style = 3) #text based bar for(i in 1:length(unique(dat.scaled$scientific_name))){ data &lt;- dat.scaled %&gt;% filter(dat.scaled$scientific_name==unique(dat.scaled$scientific_name)[i]) # Preparing data for the unmarked model occ &lt;- filter_repeat_visits(data, min_obs = 1, max_obs = 10, annual_closure = FALSE, n_days = 2200, # 6 years is considered a period of closure date_var = &quot;observation_date&quot;, site_vars = c(&quot;locality_id&quot;)) obs_covs &lt;- c(&quot;min_obs_started&quot;, &quot;duration_minutes&quot;, &quot;effort_distance_km&quot;, &quot;number_observers&quot;, &quot;protocol_type&quot;, &quot;expertise&quot;, &quot;julian_date&quot;) # format for unmarked occ_wide &lt;- format_unmarked_occu(occ, site_id = &quot;site&quot;, response = &quot;pres_abs&quot;, site_covs = c( &quot;locality_id&quot;,&quot;lc_01.y&quot;,&quot;lc_02.y&quot;,&quot;lc_03.y&quot;, &quot;lc_04.y&quot;, &quot;lc_05.y&quot;, &quot;lc_06.y&quot;, &quot;lc_07.y&quot;,&quot;prec_interannual.y&quot;,&quot;temp_interannual.y&quot;), obs_covs = obs_covs) # Convert this dataframe of observations into an unmarked object to start fitting occupancy models occ_um &lt;- formatWide(occ_wide, type = &quot;unmarkedFrameOccu&quot;) # Subset - usr model_lc_clim &lt;- occu(~min_obs_started+ julian_date + duration_minutes + effort_distance_km + number_observers + protocol_type + expertise~lc_01.y + lc_02.y +lc_03.y + lc_04.y + lc_05.y + lc_06.y + prec_interannual.y + temp_interannual.y, data = occ_um) # Set up the cluster clusterType &lt;- if(length(find.package(&quot;snow&quot;, quiet = TRUE))) &quot;SOCK&quot; else &quot;PSOCK&quot; clust &lt;- try(makeCluster(getOption(&quot;cl.cores&quot;, 6), type = clusterType)) clusterEvalQ(clust, library(unmarked)) clusterExport(clust, &quot;occ_um&quot;) # Detection terms are fixed det_terms &lt;- c(&quot;p(duration_minutes)&quot;,&quot;p(effort_distance_km)&quot;, &quot;p(expertise)&quot;,&quot;p(julian_date)&quot;,&quot;p(min_obs_started)&quot;, &quot;p(number_observers)&quot;,&quot;p(protocol_type)&quot;) # Dredging lc_clim[[i]] &lt;- pdredge(model_lc_clim, clust, fixed=det_terms) names(lc_clim)[i] &lt;- unique(dat.scaled$scientific_name)[i] # Identiying top subset of models based on deltaAIC scores being less than 4 (Burnham et al., 2011) top_lc_clim[[i]] &lt;- get.models(lc_clim[[i]], subset = delta&lt;4, cluster = clust) names(top_lc_clim)[i] &lt;- unique(dat.scaled$scientific_name)[i] # Obtaining model averaged coefficients for both candidate model subsets if(length(top_lc_clim[[i]])&gt;1){ a &lt;- model.avg(top_lc_clim[[i]], fit = TRUE) lc_clim_avg[[i]] &lt;- as.data.frame(a$coefficients) names(lc_clim_avg)[i] &lt;- unique(dat.scaled$scientific_name)[i] lc_clim_modelEst[[i]] &lt;- data.frame(Predictor = rownames(coefTable(a, full = T)), Coefficient = coefTable(a, full = T)[,1], SE = coefTable(a, full = T)[,2], lowerCI = confint(a)[,1], upperCI = confint(a)[,2]) names(lc_clim_modelEst)[i] &lt;- unique(dat.scaled$scientific_name)[i] lc_clim_imp[[i]] &lt;- as.data.frame(MuMIn::importance(a)) names(lc_clim_imp)[i] &lt;- unique(dat.scaled$scientific_name)[i] } else { lc_clim_avg[[i]] &lt;- as.data.frame(unmarked::coef(top_lc_clim[[i]][[1]])) names(lc_clim_avg)[i] &lt;- unique(dat.scaled$scientific_name)[i] lowSt &lt;- data.frame(lowerCI=confint(top_lc_clim[[i]][[1]], type=&quot;state&quot;)[,1]) lowDet &lt;- data.frame(lowerCI=confint(top_lc_clim[[i]][[1]], type=&quot;det&quot;)[,1]) upSt &lt;- data.frame(upperCI=confint(top_lc_clim[[i]][[1]], type=&quot;state&quot;)[,2]) upDet &lt;- data.frame(upperCI=confint(top_lc_clim[[i]][[1]], type=&quot;det&quot;)[,2]) lc_clim_modelEst[[i]] &lt;- data.frame(Predictor = rownames(coefTable(top_lc_clim[[i]][[1]])), Coefficient = coefTable(top_lc_clim[[i]][[1]])[,1], SE = coefTable(top_lc_clim[[i]][[1]])[,2], lowerCI = rbind(lowSt,lowDet), upperCI = rbind(upSt,upDet)) names(lc_clim_modelEst)[i] &lt;- unique(dat.scaled$scientific_name)[i] } setTxtProgressBar(pb, i) stopCluster(clust) } close(pb) # 1. Store all the dredged model outputs for each species (for lc1_elev, lc2_elev and clim_elev) write.xlsx(lc_clim ,file=&quot;C:\\\\Users\\\\vr235\\\\Downloads\\\\lc_clim.xlsx&quot;) # 2. Store all the model averaged outputs for each species and the relative importance score write.xlsx(lc_clim_avg, file = &quot;C:\\\\Users\\\\vr235\\\\Downloads\\\\lc_clim_avg.xlsx&quot;, rowNames=T, colNames=T) write.xlsx(lc_clim_imp, file = &quot;C:\\\\Users\\\\vr235\\\\Downloads\\\\lc_clim_imp.xlsx&quot;, rowNames=T, colNames=T) write.xlsx(lc_clim_modelEst, file = &quot;C:\\\\Users\\\\vr235\\\\Downloads\\\\lc_clim_modelEst.xlsx&quot;, rowNames=T, colNames=T) 6.9 The interaction between inter-annual variation in temperature and land cover dat.scaled &lt;- fread(&quot;K:\\\\Chapter 2_Occupancy Modeling\\\\Data\\\\SpeciesCovariateData\\\\5_scaled_Covs.csv&quot;,header=T) setDF(dat.scaled) head(dat.scaled) # All dredged models are stored in lists below lc_temp1 &lt;- list() lc_temp2 &lt;- list() # Subsetting those models whose deltaAIC&lt;4 (Burnham et al., 2011) top_lc_temp1 &lt;- list() top_lc_temp2 &lt;- list() # Getting model averaged coefficients lc_temp1_avg &lt;- list() lc_temp1_imp &lt;- list() lc_temp2_avg &lt;- list() lc_temp2_imp &lt;- list() # Getting model estimates lc_temp1_modelEst &lt;- list() lc_temp2_modelEst &lt;- list() # Add a progress bar for the loop pb &lt;- txtProgressBar(min = 0, max = length(unique(dat.scaled$scientific_name)), style = 3) #text based bar for(i in 1:length(unique(dat.scaled$scientific_name))){ data &lt;- dat.scaled %&gt;% filter(dat.scaled$scientific_name==unique(dat.scaled$scientific_name)[i]) # Preparing data for the unmarked model occ &lt;- filter_repeat_visits(data, min_obs = 1, max_obs = 10, annual_closure = FALSE, n_days = 2200, # 6 years is considered a period of closure date_var = &quot;observation_date&quot;, site_vars = c(&quot;locality_id&quot;)) obs_covs &lt;- c(&quot;min_obs_started&quot;, &quot;duration_minutes&quot;, &quot;effort_distance_km&quot;, &quot;number_observers&quot;, &quot;protocol_type&quot;, &quot;expertise&quot;, &quot;julian_date&quot;) # format for unmarked occ_wide &lt;- format_unmarked_occu(occ, site_id = &quot;site&quot;, response = &quot;pres_abs&quot;, site_covs = c( &quot;locality_id&quot;,&quot;lc_01.y&quot;,&quot;lc_02.y&quot;,&quot;lc_03.y&quot;, &quot;lc_04.y&quot;, &quot;lc_05.y&quot;, &quot;lc_06.y&quot;, &quot;lc_07.y&quot;,&quot;prec_interannual.y&quot;,&quot;temp_interannual.y&quot;), obs_covs = obs_covs) # Convert this dataframe of observations into an unmarked object to start fitting occupancy models occ_um &lt;- formatWide(occ_wide, type = &quot;unmarkedFrameOccu&quot;) # Subset - global models model_lc_temp1 &lt;- occu(~min_obs_started+ julian_date + duration_minutes + effort_distance_km + number_observers + protocol_type + expertise~lc_02.y*temp_interannual.y +lc_03.y*temp_interannual.y + lc_04.y*temp_interannual.y + lc_06.y*temp_interannual.y, data = occ_um) model_lc_temp2 &lt;- occu(~min_obs_started+ julian_date + duration_minutes + effort_distance_km + number_observers + protocol_type + expertise~lc_01.y*temp_interannual.y + lc_05.y*temp_interannual.y + lc_07.y*temp_interannual.y, data = occ_um) # Set up the cluster clusterType &lt;- if(length(find.package(&quot;snow&quot;, quiet = TRUE))) &quot;SOCK&quot; else &quot;PSOCK&quot; clust &lt;- try(makeCluster(getOption(&quot;cl.cores&quot;, 6), type = clusterType)) clusterEvalQ(clust, library(unmarked)) clusterExport(clust, &quot;occ_um&quot;) # Detection terms are fixed det_terms &lt;- c(&quot;p(duration_minutes)&quot;,&quot;p(effort_distance_km)&quot;, &quot;p(expertise)&quot;,&quot;p(julian_date)&quot;,&quot;p(min_obs_started)&quot;, &quot;p(number_observers)&quot;,&quot;p(protocol_type)&quot;) # Dredging lc_temp1[[i]] &lt;- pdredge(model_lc_temp1, clust, fixed=det_terms) lc_temp2[[i]] &lt;- pdredge(model_lc_temp2, clust, fixed=det_terms) names(lc_temp1)[i] &lt;- unique(dat.scaled$scientific_name)[i] names(lc_temp2)[i] &lt;- unique(dat.scaled$scientific_name)[i] # Identiying top subset of models based on deltaAIC scores being less than 4 (Burnham et al., 2011) top_lc_temp1[[i]] &lt;- get.models(lc_temp1[[i]], subset = delta&lt;4, cluster = clust) top_lc_temp2[[i]] &lt;- get.models(lc_temp2[[i]], subset = delta&lt;4, cluster = clust) names(top_lc_temp1)[i] &lt;- unique(dat.scaled$scientific_name)[i] names(top_lc_temp2)[i] &lt;- unique(dat.scaled$scientific_name)[i] # Obtaining model averaged coefficients for both candidate model subsets if(length(top_lc_temp1[[i]])&gt;1){ a &lt;- model.avg(top_lc_temp1[[i]], fit = TRUE) lc_temp1_avg[[i]] &lt;- as.data.frame(a$coefficients) names(lc_temp1_avg)[i] &lt;- unique(dat.scaled$scientific_name)[i] lc_temp1_modelEst[[i]] &lt;- data.frame(Predictor = rownames(coefTable(a, full = T)), Coefficient = coefTable(a, full = T)[,1], SE = coefTable(a, full = T)[,2], lowerCI = confint(a)[,1], upperCI = confint(a)[,2]) names(lc_temp1_modelEst)[i] &lt;- unique(dat.scaled$scientific_name)[i] lc_temp1_imp[[i]] &lt;- as.data.frame(MuMIn::importance(a)) names(lc_temp1_imp)[i] &lt;- unique(dat.scaled$scientific_name)[i] } else { lc_temp1_avg[[i]] &lt;- as.data.frame(unmarked::coef(top_lc_temp1[[i]][[1]])) names(lc_temp1_avg)[i] &lt;- unique(dat.scaled$scientific_name)[i] lowSt &lt;- data.frame(lowerCI=confint(top_lc_temp1[[i]][[1]], type=&quot;state&quot;)[,1]) lowDet &lt;- data.frame(lowerCI=confint(top_lc_temp1[[i]][[1]], type=&quot;det&quot;)[,1]) upSt &lt;- data.frame(upperCI=confint(top_lc_temp1[[i]][[1]], type=&quot;state&quot;)[,2]) upDet &lt;- data.frame(upperCI=confint(top_lc_temp1[[i]][[1]], type=&quot;det&quot;)[,2]) lc_temp1_modelEst[[i]] &lt;- data.frame(Predictor = rownames(coefTable(top_lc_temp1[[i]][[1]])), Coefficient = coefTable(top_lc_temp1[[i]][[1]])[,1], SE = coefTable(top_lc_temp1[[i]][[1]])[,2], lowerCI = rbind(lowSt,lowDet), upperCI = rbind(upSt,upDet)) names(lc_temp1_modelEst)[i] &lt;- unique(dat.scaled$scientific_name)[i] } if(length(top_lc_temp2[[i]])&gt;1){ b &lt;- model.avg(top_lc_temp2[[i]], fit = TRUE) lc_temp2_avg[[i]] &lt;- as.data.frame(b$coefficients) names(lc_temp2_avg)[i] &lt;- unique(dat.scaled$scientific_name)[i] lc_temp2_modelEst[[i]] &lt;- data.frame(Predictor = rownames(coefTable(b, full = T)), Coefficient = coefTable(b, full = T)[,1], SE = coefTable(b, full = T)[,2], lowerCI = confint(b)[,1], upperCI = confint(b)[,2]) names(lc_temp2_modelEst)[i] &lt;- unique(dat.scaled$scientific_name)[i] lc_temp2_imp[[i]] &lt;- as.data.frame(MuMIn::importance(b)) names(lc_temp2_imp)[i] &lt;- unique(dat.scaled$scientific_name)[i] } else { lc_temp2_avg[[i]] &lt;- as.data.frame(unmarked::coef(top_lc_temp2[[i]][[1]])) names(lc_temp2_avg)[i] &lt;- unique(dat.scaled$scientific_name)[i] lowSt &lt;- data.frame(lowerCI=confint(top_lc_temp2[[i]][[1]], type=&quot;state&quot;)[,1]) lowDet &lt;- data.frame(lowerCI=confint(top_lc_temp2[[i]][[1]], type=&quot;det&quot;)[,1]) upSt &lt;- data.frame(upperCI=confint(top_lc_temp2[[i]][[1]], type=&quot;state&quot;)[,2]) upDet &lt;- data.frame(upperCI=confint(top_lc_temp2[[i]][[1]], type=&quot;det&quot;)[,2]) lc_temp2_modelEst[[i]] &lt;- data.frame(Predictor = rownames(coefTable(top_lc_temp2[[i]][[1]])), Coefficient = coefTable(top_lc_temp2[[i]][[1]])[,1], SE = coefTable(top_lc_temp2[[i]][[1]])[,2], lowerCI = rbind(lowSt,lowDet), upperCI = rbind(upSt,upDet)) names(lc_temp2_modelEst)[i] &lt;- unique(dat.scaled$scientific_name)[i] } setTxtProgressBar(pb, i) stopCluster(clust) } close(pb) # 1. Store all the dredged model outputs for each species (for lc1_temp and lc2_temp) write.xlsx(lc_temp1 ,file=&quot;C:\\\\Users\\\\vr235\\\\Downloads\\\\lc_temp1.xlsx&quot;) write.xlsx(lc_temp2 ,file=&quot;C:\\\\Users\\\\vr235\\\\Downloads\\\\lc_temp2.xlsx&quot;) # 2. Store all the model averaged outputs for each species and the relative importance score write.xlsx(lc_temp1_avg, file = &quot;C:\\\\Users\\\\vr235\\\\Downloads\\\\lc_temp1_avg.xlsx&quot;, rowNames=T, colNames=T) write.xlsx(lc_temp2_avg, file = &quot;C:\\\\Users\\\\vr235\\\\Downloads\\\\lc_temp2_avg.xlsx&quot;, rowNames=T, colNames=T) write.xlsx(lc_temp1_imp, file = &quot;C:\\\\Users\\\\vr235\\\\Downloads\\\\lc_temp1_imp.xlsx&quot;, rowNames=T, colNames=T) write.xlsx(lc_temp2_imp, file = &quot;C:\\\\Users\\\\vr235\\\\Downloads\\\\lc_temp2_imp.xlsx&quot;, rowNames=T, colNames=T) write.xlsx(lc_temp1_modelEst, file = &quot;C:\\\\Users\\\\vr235\\\\Downloads\\\\lc_temp1_modelEst.xlsx&quot;, rowNames=T, colNames=T) write.xlsx(lc_temp2_modelEst, file = &quot;C:\\\\Users\\\\vr235\\\\Downloads\\\\lc_temp2_modelEst.xlsx&quot;, rowNames=T, colNames=T) 6.10 The interaction between inter-annual variation in precip and land cover dat.scaled &lt;- fread(&quot;K:\\\\Chapter 2_Occupancy Modeling\\\\Data\\\\SpeciesCovariateData\\\\5_scaled_Covs.csv&quot;,header=T) setDF(dat.scaled) head(dat.scaled) # All dredged models are stored in lists below lc_prec1 &lt;- list() lc_prec2 &lt;- list() # Subsetting those models whose deltaAIC&lt;4 (Burnham et al., 2011) top_lc_prec1 &lt;- list() top_lc_prec2 &lt;- list() # Getting model averaged coefficients lc_prec1_avg &lt;- list() lc_prec1_imp &lt;- list() lc_prec2_avg &lt;- list() lc_prec2_imp &lt;- list() # Getting model estimates lc_prec1_modelEst &lt;- list() lc_prec2_modelEst &lt;- list() # Add a progress bar for the loop pb &lt;- txtProgressBar(min = 0, max = length(unique(dat.scaled$scientific_name)), style = 3) #text based bar for(i in 1:length(unique(dat.scaled$scientific_name))){ data &lt;- dat.scaled %&gt;% filter(dat.scaled$scientific_name==unique(dat.scaled$scientific_name)[i]) # Preparing data for the unmarked model occ &lt;- filter_repeat_visits(data, min_obs = 1, max_obs = 10, annual_closure = FALSE, n_days = 2200, # 6 years is considered a period of closure date_var = &quot;observation_date&quot;, site_vars = c(&quot;locality_id&quot;)) obs_covs &lt;- c(&quot;min_obs_started&quot;, &quot;duration_minutes&quot;, &quot;effort_distance_km&quot;, &quot;number_observers&quot;, &quot;protocol_type&quot;, &quot;expertise&quot;, &quot;julian_date&quot;) # format for unmarked occ_wide &lt;- format_unmarked_occu(occ, site_id = &quot;site&quot;, response = &quot;pres_abs&quot;, site_covs = c( &quot;locality_id&quot;,&quot;lc_01.y&quot;,&quot;lc_02.y&quot;,&quot;lc_03.y&quot;, &quot;lc_04.y&quot;, &quot;lc_05.y&quot;, &quot;lc_06.y&quot;, &quot;lc_07.y&quot;,&quot;prec_interannual.y&quot;,&quot;temp_interannual.y&quot;), obs_covs = obs_covs) # Convert this dataframe of observations into an unmarked object to start fitting occupancy models occ_um &lt;- formatWide(occ_wide, type = &quot;unmarkedFrameOccu&quot;) # Subset - global models model_lc_prec1 &lt;- occu(~min_obs_started+ julian_date + duration_minutes + effort_distance_km + number_observers + protocol_type + expertise~lc_02.y*prec_interannual.y +lc_03.y*prec_interannual.y + lc_04.y*prec_interannual.y + lc_06.y*prec_interannual.y, data = occ_um) model_lc_prec2 &lt;- occu(~min_obs_started+ julian_date + duration_minutes + effort_distance_km + number_observers + protocol_type + expertise~lc_01.y*prec_interannual.y + lc_05.y*prec_interannual.y + lc_07.y*prec_interannual.y, data = occ_um) # Set up the cluster clusterType &lt;- if(length(find.package(&quot;snow&quot;, quiet = TRUE))) &quot;SOCK&quot; else &quot;PSOCK&quot; clust &lt;- try(makeCluster(getOption(&quot;cl.cores&quot;, 6), type = clusterType)) clusterEvalQ(clust, library(unmarked)) clusterExport(clust, &quot;occ_um&quot;) # Detection terms are fixed det_terms &lt;- c(&quot;p(duration_minutes)&quot;,&quot;p(effort_distance_km)&quot;, &quot;p(expertise)&quot;,&quot;p(julian_date)&quot;,&quot;p(min_obs_started)&quot;, &quot;p(number_observers)&quot;,&quot;p(protocol_type)&quot;) # Dredging lc_prec1[[i]] &lt;- pdredge(model_lc_prec1, clust, fixed=det_terms) lc_prec2[[i]] &lt;- pdredge(model_lc_prec2, clust, fixed=det_terms) names(lc_prec1)[i] &lt;- unique(dat.scaled$scientific_name)[i] names(lc_prec2)[i] &lt;- unique(dat.scaled$scientific_name)[i] # Identiying top subset of models based on deltaAIC scores being less than 4 (Burnham et al., 2011) top_lc_prec1[[i]] &lt;- get.models(lc_prec1[[i]], subset = delta&lt;4, cluster = clust) top_lc_prec2[[i]] &lt;- get.models(lc_prec2[[i]], subset = delta&lt;4, cluster = clust) names(top_lc_prec1)[i] &lt;- unique(dat.scaled$scientific_name)[i] names(top_lc_prec2)[i] &lt;- unique(dat.scaled$scientific_name)[i] # Obtaining model averaged coefficients for both candidate model subsets if(length(top_lc_prec1[[i]])&gt;1){ a &lt;- model.avg(top_lc_prec1[[i]], fit = TRUE) lc_prec1_avg[[i]] &lt;- as.data.frame(a$coefficients) names(lc_prec1_avg)[i] &lt;- unique(dat.scaled$scientific_name)[i] lc_prec1_modelEst[[i]] &lt;- data.frame(Predictor = rownames(coefTable(a, full = T)), Coefficient = coefTable(a, full = T)[,1], SE = coefTable(a, full = T)[,2], lowerCI = confint(a)[,1], upperCI = confint(a)[,2]) names(lc_prec1_modelEst)[i] &lt;- unique(dat.scaled$scientific_name)[i] lc_prec1_imp[[i]] &lt;- as.data.frame(MuMIn::importance(a)) names(lc_prec1_imp)[i] &lt;- unique(dat.scaled$scientific_name)[i] } else { lc_prec1_avg[[i]] &lt;- as.data.frame(unmarked::coef(top_lc_prec1[[i]][[1]])) names(lc_prec1_avg)[i] &lt;- unique(dat.scaled$scientific_name)[i] lowSt &lt;- data.frame(lowerCI=confint(top_lc_prec1[[i]][[1]], type=&quot;state&quot;)[,1]) lowDet &lt;- data.frame(lowerCI=confint(top_lc_prec1[[i]][[1]], type=&quot;det&quot;)[,1]) upSt &lt;- data.frame(upperCI=confint(top_lc_prec1[[i]][[1]], type=&quot;state&quot;)[,2]) upDet &lt;- data.frame(upperCI=confint(top_lc_prec1[[i]][[1]], type=&quot;det&quot;)[,2]) lc_prec1_modelEst[[i]] &lt;- data.frame(Predictor = rownames(coefTable(top_lc_prec1[[i]][[1]])), Coefficient = coefTable(top_lc_prec1[[i]][[1]])[,1], SE = coefTable(top_lc_prec1[[i]][[1]])[,2], lowerCI = rbind(lowSt,lowDet), upperCI = rbind(upSt,upDet)) names(lc_prec1_modelEst)[i] &lt;- unique(dat.scaled$scientific_name)[i] } if(length(top_lc_prec2[[i]])&gt;1){ b &lt;- model.avg(top_lc_prec2[[i]], fit = TRUE) lc_prec2_avg[[i]] &lt;- as.data.frame(b$coefficients) names(lc_prec2_avg)[i] &lt;- unique(dat.scaled$scientific_name)[i] lc_prec2_modelEst[[i]] &lt;- data.frame(Predictor = rownames(coefTable(b, full = T)), Coefficient = coefTable(b, full = T)[,1], SE = coefTable(b, full = T)[,2], lowerCI = confint(b)[,1], upperCI = confint(b)[,2]) names(lc_prec2_modelEst)[i] &lt;- unique(dat.scaled$scientific_name)[i] lc_prec2_imp[[i]] &lt;- as.data.frame(MuMIn::importance(b)) names(lc_prec2_imp)[i] &lt;- unique(dat.scaled$scientific_name)[i] } else { lc_prec2_avg[[i]] &lt;- as.data.frame(unmarked::coef(top_lc_prec2[[i]][[1]])) names(lc_prec2_avg)[i] &lt;- unique(dat.scaled$scientific_name)[i] lowSt &lt;- data.frame(lowerCI=confint(top_lc_prec2[[i]][[1]], type=&quot;state&quot;)[,1]) lowDet &lt;- data.frame(lowerCI=confint(top_lc_prec2[[i]][[1]], type=&quot;det&quot;)[,1]) upSt &lt;- data.frame(upperCI=confint(top_lc_prec2[[i]][[1]], type=&quot;state&quot;)[,2]) upDet &lt;- data.frame(upperCI=confint(top_lc_prec2[[i]][[1]], type=&quot;det&quot;)[,2]) lc_prec2_modelEst[[i]] &lt;- data.frame(Predictor = rownames(coefTable(top_lc_prec2[[i]][[1]])), Coefficient = coefTable(top_lc_prec2[[i]][[1]])[,1], SE = coefTable(top_lc_prec2[[i]][[1]])[,2], lowerCI = rbind(lowSt,lowDet), upperCI = rbind(upSt,upDet)) names(lc_prec2_modelEst)[i] &lt;- unique(dat.scaled$scientific_name)[i] } setTxtProgressBar(pb, i) stopCluster(clust) } close(pb) # 1. Store all the dredged model outputs for each species (for lc1_temp and lc2_temp) write.xlsx(lc_prec1 ,file=&quot;C:\\\\Users\\\\vr235\\\\Downloads\\\\lc_prec1.xlsx&quot;) write.xlsx(lc_prec2 ,file=&quot;C:\\\\Users\\\\vr235\\\\Downloads\\\\lc_prec2.xlsx&quot;) # 2. Store all the model averaged outputs for each species and the relative importance score write.xlsx(lc_prec1_avg, file = &quot;C:\\\\Users\\\\vr235\\\\Downloads\\\\lc_prec1_avg.xlsx&quot;, rowNames=T, colNames=T) write.xlsx(lc_prec2_avg, file = &quot;C:\\\\Users\\\\vr235\\\\Downloads\\\\lc_prec2_avg.xlsx&quot;, rowNames=T, colNames=T) write.xlsx(lc_prec1_imp, file = &quot;C:\\\\Users\\\\vr235\\\\Downloads\\\\lc_prec1_imp.xlsx&quot;, rowNames=T, colNames=T) write.xlsx(lc_prec2_imp, file = &quot;C:\\\\Users\\\\vr235\\\\Downloads\\\\lc_prec2_imp.xlsx&quot;, rowNames=T, colNames=T) write.xlsx(lc_prec1_modelEst, file = &quot;C:\\\\Users\\\\vr235\\\\Downloads\\\\lc_prec1_modelEst.xlsx&quot;, rowNames=T, colNames=T) write.xlsx(lc_prec2_modelEst, file = &quot;C:\\\\Users\\\\vr235\\\\Downloads\\\\lc_prec2_modelEst.xlsx&quot;, rowNames=T, colNames=T) "],
["supplementary-material.html", "Section 7 Supplementary material 7.1 Distance to roads 7.2 Species observation distributions 7.3 Climate in relation to elevation 7.4 Climate in relation to landcover", " Section 7 Supplementary material 7.1 Distance to roads 7.1.1 Prepare libraries # load libraries library(reticulate) library(ggplot2) library(ggthemes) # set python path use_python(&quot;/usr/bin/python3&quot;) Importing python libraries. # import classic python libs import itertools from operator import itemgetter import numpy as np import matplotlib.pyplot as plt import math # libs for dataframes import pandas as pd # import libs for geodata from shapely.ops import nearest_points import geopandas as gpd import rasterio # import ckdtree from scipy.spatial import cKDTree from shapely.geometry import Point, MultiPoint, LineString, MultiLineString 7.1.2 Prepare data for processing # read in roads shapefile roads = gpd.read_file(&quot;data/spatial/roads_studysite_2019/roads_studysite_2019.shp&quot;) roads.head() # read in checklist covariates for conversion to gpd # get unique coordinates, assign them to the df # convert df to geo-df chkCovars = pd.read_csv(&quot;data/eBirdChecklistVars.csv&quot;) unique_locs = chkCovars.drop_duplicates(subset=[&#39;longitude&#39;,&#39;latitude&#39;])[[&#39;longitude&#39;, &#39;latitude&#39;, &#39;nSp&#39;]] unique_locs[&#39;coordId&#39;] = np.arange(1, unique_locs.shape[0]+1) chkCovars = chkCovars.merge(unique_locs, on=[&#39;longitude&#39;, &#39;latitude&#39;]) unique_locs = gpd.GeoDataFrame( unique_locs, geometry=gpd.points_from_xy(unique_locs.longitude, unique_locs.latitude)) unique_locs.crs = {&#39;init&#39; :&#39;epsg:4326&#39;} # reproject spatials to 43n epsg 32642 roads = roads.to_crs({&#39;init&#39;: &#39;epsg:32642&#39;}) unique_locs = unique_locs.to_crs({&#39;init&#39;: &#39;epsg:32642&#39;}) # function to simplify multilinestrings def simplify_roads(complex_roads): simpleRoads = [] for i in range(len(complex_roads.geometry)): feature = complex_roads.geometry.iloc[i] if feature.geom_type == &quot;LineString&quot;: simpleRoads.append(feature) elif feature.geom_type == &quot;MultiLineString&quot;: for road_level2 in feature: simpleRoads.append(road_level2) return simpleRoads # function to use ckdtrees for nearest point finding def ckdnearest(gdfA, gdfB): A = np.concatenate( [np.array(geom.coords) for geom in gdfA.geometry.to_list()]) simplified_features = simplify_roads(gdfB) B = [np.array(geom.coords) for geom in simplified_features] B = np.concatenate(B) ckd_tree = cKDTree(B) dist, idx = ckd_tree.query(A, k=1) return dist # get distance to nearest road unique_locs[&#39;dist_road&#39;] = ckdnearest(unique_locs, roads) # write to file unique_locs = pd.DataFrame(unique_locs.drop(columns=&#39;geometry&#39;)) unique_locs[&#39;dist_road&#39;] = unique_locs[&#39;dist_road&#39;] unique_locs.to_csv(path_or_buf=&quot;data/locs_dist_to_road.csv&quot;, index=False) # merge unique locs with chkCovars chkCovars = chkCovars.merge(unique_locs, on=[&#39;latitude&#39;, &#39;longitude&#39;, &#39;coordId&#39;]) 7.1.3 Plot histogram: distance to roads # extract data from python chkCovars &lt;- py$chkCovars # make histogram hist_roads &lt;- ggplot(chkCovars)+ geom_histogram(aes(dist_road / 1e3), bins = 20, size=0.2, fill=&quot;steelblue&quot;)+ labs(x = &quot;distance to roads (km)&quot;, y = &quot;# checklists&quot;)+ scale_x_log10(label=label_number(accuracy = 0.1), breaks = c(0.1, 1, 10))+ scale_y_continuous(label=label_number(scale=0.001, suffix = &quot;K&quot;))+ theme_few()+ theme(plot.background = element_rect(fill=&quot;white&quot;, colour = 1), panel.background = element_blank(), panel.border = element_blank(), axis.line = element_blank()) 7.1.4 Plot map: points on roads # load data into R library(sf) library(ggspatial) hills &lt;- st_read(&quot;data/spatial/hillsShapefile/Nil_Ana_Pal.shp&quot;) roads &lt;- st_read(&quot;data/spatial/roads_studysite_2019/roads_studysite_2019.shp&quot;) points &lt;- read_csv(&quot;data/locs_dist_to_road.csv&quot;) %&gt;% st_as_sf(coords = c(&quot;longitude&quot;,&quot;latitude&quot;)) %&gt;% `st_crs&lt;-`(4326) # plot on maps ggplot(hills)+ geom_sf(fill=&quot;transparent&quot;, col = 2)+ geom_sf(data=roads, col=&quot;steelblue&quot;, size=0.2)+ geom_sf(data=points, aes(col=dist_road), size = 0.1, col = &quot;grey40&quot;)+ annotation_custom(grob = hist_roads %&gt;% ggplotGrob(), xmin = 77.1, xmax = 77.8, ymin = 10.9, ymax = 11.5)+ annotation_scale(location = &quot;br&quot;, width_hint = 0.4, text_cex = 1) + annotation_north_arrow(location = &quot;br&quot;, which_north = &quot;true&quot;, pad_x = unit(0.1, &quot;in&quot;), pad_y = unit(0.5, &quot;in&quot;), style = north_arrow_fancy_orienteering) + theme_few()+ theme(legend.position = &quot;none&quot;)+ coord_sf(expand = FALSE) # save figure ggsave(filename = &quot;figs/fig_distRoads.png&quot;, device = png()) dev.off() (#fig:plot_figure1)Checklist locations in the Nilgiris. Inset histogram shows checklists’ distance to the nearest road, with the X-axis on a log-scale. 7.2 Species observation distributions 7.2.1 Prepare libraries # load libraries library(data.table) library(readxl) library(magrittr) library(stringr) library(dplyr) library(ggplot2) library(ggthemes) 7.2.2 Read species of interest # add species of interest specieslist &lt;- read_excel(&quot;data/species_list_13_11_2019.xlsx&quot;) speciesOfInterest &lt;- specieslist$scientific_name 7.2.3 Load raw data for locations # read in shapefile of nilgiris to subset by bounding box library(sf) wg &lt;- st_read(&quot;data/spatial/hillsShapefile/Nil_Ana_Pal.shp&quot;); box &lt;- st_bbox(wg) # read in data and subset ebd &lt;- fread(&quot;ebd_Filtered_Jun2019.txt&quot;) ebd &lt;- ebd[between(LONGITUDE, box[&quot;xmin&quot;], box[&quot;xmax&quot;]) &amp; between(LATITUDE, box[&quot;ymin&quot;], box[&quot;ymax&quot;]),] ebd &lt;- ebd[year(`OBSERVATION DATE`) &gt;= 2013,] # make new column names newNames &lt;- str_replace_all(colnames(ebd), &quot; &quot;, &quot;_&quot;) %&gt;% str_to_lower() setnames(ebd, newNames) # keep useful columns columnsOfInterest &lt;- c(&quot;scientific_name&quot;,&quot;observation_count&quot;,&quot;locality&quot;,&quot;locality_id&quot;,&quot;locality_type&quot;,&quot;latitude&quot;,&quot;longitude&quot;,&quot;observation_date&quot;, &quot;sampling_event_identifier&quot;) # keep species of interest ebd &lt;- ebd[scientific_name %in% speciesOfInterest,] ebd &lt;- select(ebd, one_of(columnsOfInterest)) 7.2.4 Get proportional obs counts in 20km cells # transform data to UTM zone 43N ebd &lt;- setDF(ebd) %&gt;% st_as_sf(coords = c(&quot;longitude&quot;,&quot;latitude&quot;)) %&gt;% `st_crs&lt;-`(4326) %&gt;% st_transform(32643) # add UTM coordinate columns ebd &lt;- cbind(ebd, st_coordinates(ebd)) %&gt;% st_drop_geometry() %&gt;% setDT() # round to cell size cell_size = 20000 # 20km in metres ebd[,`:=`(X_round = plyr::round_any(X, cell_size), Y_round = plyr::round_any(Y, cell_size))] # set observation count to 1 if NA or X ebd_summary &lt;- ebd[, observation_count := ifelse(observation_count == &quot;X&quot;, 1, observation_count) ][,observation_count:=as.numeric(observation_count) ][,.(count=sum(observation_count)), by = list(scientific_name, X_round, Y_round) ][,prop:=count/sum(count), by = list(scientific_name)] 7.2.5 Plot maps # get bbox bbox &lt;- wg %&gt;% st_transform(32643) %&gt;% st_bbox() # add land library(rnaturalearth) # land &lt;- ne_countries(scale = 50, type = &quot;countries&quot;, continent = &quot;asia&quot;, # country = &quot;india&quot;, # returnclass = c(&quot;sf&quot;)) # # # crop land # land &lt;- st_transform(land, 32643) %&gt;% st_crop(bbox) # make plot wg &lt;- st_transform(wg, 32643) plotDistributions &lt;- ggplot()+ # geom_sf(data = land, fill = &quot;grey99&quot;, col = &quot;transparent&quot;)+ geom_tile(data = ebd_summary, aes(X_round, Y_round, fill = prop), lwd = 0.5, col = &quot;white&quot;)+ geom_sf(data = wg, fill = &quot;transparent&quot;, col = &quot;red&quot;, lwd = 0.3)+ scale_fill_distiller(palette = &quot;Blues&quot;, direction = 1, values = c(0, 0.3), na.value = &quot;darkslateblue&quot;)+ facet_wrap(~scientific_name, ncol = 10)+ coord_sf()+ theme_few()+ theme(legend.position = &quot;none&quot;, axis.text = element_blank(), axis.title = element_blank()) # export data ggsave(plotDistributions, filename = &quot;figs/fig_species_distributions.png&quot;, height = 10, width = 16, device = png(), dpi = 300); dev.off() # show exported image knitr::include_graphics(&quot;figs/fig_species_distributions.png&quot;) (#fig:export_fig_obs_dist)Proportion of individuals observed in each grid cell (20km side) between 2013 and 2018. Deeper shades of blue indicate higher proportions in the range 0 – 0.3, values above 0.3 are coloured purple. 7.3 Climate in relation to elevation 7.3.1 Prepare libraries # load libs library(raster) library(glue) library(purrr) library(dplyr) library(tidyr) library(ggplot2) library(ggthemes) # get ci func ci &lt;- function(x){qnorm(0.975)*sd(x, na.rm = T)/sqrt(length(x))} # read landscape prepare for plotting landscape &lt;- stack(&quot;data/spatial/landscape_resamp01km.tif&quot;) # get proper names elev_names &lt;- c(&quot;elev&quot;, &quot;slope&quot;, &quot;aspect&quot;) evi_names &lt;- c(&quot;evi_01&quot;, &quot;evi_07&quot;, &quot;evi_10&quot;) chelsa_names &lt;- c(&quot;chelsa_bio10_04&quot;, &quot;chelsa_bio10_17&quot;, &quot;chelsa_bio10_18&quot;, &quot;chelsa_prec&quot;, &quot;chelsa_temp&quot;) names(landscape) &lt;- as.character(glue(&#39;{c(elev_names, evi_names, chelsa_names, &quot;landcover&quot;)}&#39;)) # make duplicate stack land_data &lt;- landscape[[c(&quot;elev&quot;, chelsa_names)]] # convert to list land_data &lt;- as.list(land_data) # map get values over the stack land_data &lt;- map(land_data, getValues) names(land_data) &lt;- c(&quot;elev&quot;, chelsa_names) # conver to dataframe and round to 100m land_data &lt;- bind_cols(land_data) land_data &lt;- drop_na(land_data) %&gt;% mutate(elev_round = plyr::round_any(elev, 200)) %&gt;% select(-elev) %&gt;% pivot_longer(cols = contains(&quot;chelsa&quot;), names_to = &quot;clim_var&quot;) %&gt;% group_by(elev_round, clim_var) %&gt;% summarise_all(.funs = list(~mean(.), ~ci(.))) 7.3.2 Plot climatic variables over elevation # plot in facets fig_climate_elev &lt;- ggplot(land_data)+ geom_line(aes(x = elev_round, y = mean), size = 0.2, col = &quot;grey&quot;)+ geom_pointrange(aes(x = elev_round, y = mean, ymin=mean-ci, ymax=mean+ci), size = 0.3)+ scale_x_continuous(labels = scales::comma)+ scale_y_continuous(labels = scales::comma)+ facet_wrap(~clim_var, scales = &quot;free_y&quot;)+ theme_few()+ labs(x = &quot;elevation (m)&quot;, y = &quot;CHELSA variable value&quot;) # save as png ggsave(fig_climate_elev, filename = &quot;figs/fig_climate_elev.png&quot;, height = 4, width = 6, device = png(), dpi = 300); dev.off() # show exported image knitr::include_graphics(&quot;figs/fig_climate_elev.png&quot;) (#fig:export_fig_clim_elev)CHELSA climatic variables as a function of elevation, in increments of 200m. Points represent means, while vertical lines show 95% confidence intervals. 7.4 Climate in relation to landcover 7.4.1 Prepare libraries # load libs library(raster) library(glue) library(purrr) library(dplyr) library(tidyr) library(ggplot2) library(ggthemes) # get ci func ci &lt;- function(x){qnorm(0.975)*sd(x, na.rm = T)/sqrt(length(x))} # read landscape prepare for plotting landscape &lt;- stack(&quot;data/spatial/landscape_resamp01km.tif&quot;) # get proper names elev_names &lt;- c(&quot;elev&quot;, &quot;slope&quot;, &quot;aspect&quot;) evi_names &lt;- c(&quot;evi_01&quot;, &quot;evi_07&quot;, &quot;evi_10&quot;) chelsa_names &lt;- c(&quot;chelsa_bio10_04&quot;, &quot;chelsa_bio10_17&quot;, &quot;chelsa_bio10_18&quot;, &quot;chelsa_prec&quot;, &quot;chelsa_temp&quot;) names(landscape) &lt;- as.character(glue(&#39;{c(elev_names, evi_names, chelsa_names, &quot;landcover&quot;)}&#39;)) # make duplicate stack land_data &lt;- landscape[[c(&quot;landcover&quot;, chelsa_names)]] # convert to list land_data &lt;- as.list(land_data) # map get values over the stack land_data &lt;- map(land_data, getValues) names(land_data) &lt;- c(&quot;landcover&quot;, chelsa_names) # conver to dataframe and round to 100m land_data &lt;- bind_cols(land_data) land_data &lt;- drop_na(land_data) %&gt;% filter(landcover != 0) %&gt;% pivot_longer(cols = contains(&quot;chelsa&quot;), names_to = &quot;clim_var&quot;) %&gt;% group_by(landcover, clim_var) %&gt;% summarise_all(.funs = list(~mean(.), ~ci(.))) 7.4.2 Plot climatic variables over landcover # plot in facets fig_climate_lc &lt;- ggplot(land_data)+ geom_pointrange(aes(x = landcover, y = mean, ymin=mean-ci, ymax=mean+ci), size = 0.3)+ # scale_x_continuous(labels = scales::comma)+ scale_y_continuous(labels = scales::comma)+ facet_wrap(~clim_var, scales = &quot;free_y&quot;)+ theme_few()+ labs(x = &quot;landcover class&quot;, y = &quot;CHELSA variable value&quot;) # save as png ggsave(fig_climate_lc, filename = &quot;figs/fig_climate_landcover.png&quot;, height = 4, width = 6, device = png(), dpi = 300); dev.off() # show exported image knitr::include_graphics(&quot;figs/fig_climate_landcover.png&quot;) (#fig:export_fig_clim_lc)CHELSA climatic variables as a function of landcover class. Points represent means, while vertical lines show 95% confidence intervals. "]
]
